1. INTRODUCTORY REMARKS: WHY DO WE NEED ARCHITECTURES AND PATTERNS?

Look at the architectural diagram below. It depicts the architecture, or to put it 
better, the complete lack thereof, in a poorly designed monolithic application. 
Applications that are poorly designed tend to have major components mixed together into
an incoherent mess.


    +--------------------------------------------------------------------------------------------+
    |                                                                                            |
    |           MONOLITHIC APPLICATION WITH TERRIBLE ARCHITECTURE                                |
    |                                                                                            |
    |  +--------------------------------------------------------------------+                    |
    |  |            +----------+                                            |    +------------+  |
    |  |  PRESENTATION         v                                            |    |            |  |
    |  |     ^ LAYER BUSINESS LOGIC+-----------------------------+          |    |            |  |
    |  |     |       LAYER ^                                     v          |    |            |  |
    |  |     +----------+  |                                DATA ACCESS+-------> |  DATABASE  |  |
    |  |                   |                                   LAYER  <--------+ |            |  |
    |  |                   +-------------------------------------+          |    |            |  |
    |  |                                                                    |    |            |  |
    |  |                                                                    |    +------------+  |
    |  +--------------------------------------------------------------------+                    |
    |                                                                                            |
    +--------------------------------------------------------------------------------------------+

                                      RUNS ON A SINGLE MACHINE


Jason Ables explains the situation:[] (https://www.ethode.com/blog/fixing-spaghetti-how-to-work-with-legacy-code)

    Legacy code is software that generates value for a business but is difficult for 
    developers to change. The terms "code rot" and "spaghetti code" refer to legacy code 
    that is tangled up in poor quality. Over time, as "get it done now" is continually 
    favored over "get it done right", the code base decays by avoiding industry best 
    practices, making it tightly coupled, difficult to test, and increasingly prone to 
    defects.

    The longer this goes on, the more frustrated customers get with the software due to 
    quirky defects, bad user experiences and long lead times for changes. Developers are 
    afraid to make changes due to the "Jenga effect" -- as one piece of code is changed 
    or removed, it often leads to new defects being introduced in the system in sometimes 
    seemingly unrelated places. This compounds into what is known as "technical debt".
    
    Just like financial debt, technical debt is sometimes a calculated risk. For example, 
    you may incur technical debt in order to get a software product to market faster. 
    However, just like financial debt, the longer this goes unpaid, especially if it 
    continues to grow, the more it hinders your technical flow. Just like cash flow, 
    technical flow is critical to the health of an organization. Technical flow is the 
    ability for developers to respond quickly to change.


There are many failures that lead to a spaghetti codebase, and this article will discuss
one aspect: Architectures and Patterns. At the start of every project, the developer 
(team) needs to carefully choose architectural designs for it. The architectural styles
and patterns used to structure a project will in large part determine its quality. A 
program with a good design will have built-in resistance to decaying. 

Web projects like the Hotel-Reservation-System Project (HRSP) are structured into 
sub-components by implementing certain architecture styles and patterns. Dividing code 
into clearly demarcated modules has been found to make programs simpler to develop, 
maintain and extend, and easier to debug. This article will discuss architectural 
concepts required to develop web applications.

First, basic architectural concepts will be discussed:


    1. Introduction to Software Architectures
    2. Architectural Styles
    3. Architectural Patterns
    4. Enabling Techniques
    5. Architectural Principles: Layers and Tiers


2.1 AN INTRODUCTION TO PROGRAM STRUCTURES & ARCHITECTURES

From Robert Hanmer's book Pattern-Oriented Software Architecture For Dummies, here's a 
definition of Software Architecture, Page 9[1]:


    Every system has an architecture — some high-level structure that underlies the whole 
    system. Software architecture is how the pieces fit together to build the solution to 
    some business or technical need that your customer or client wants solved. The 
    architecture has a purpose.
    
    The decisions made during the creation of the architecture are truly fundamental to 
    the system because they set the stage for all the other decisions that will come 
    later.


When a programmer designs a software solution's architecture, she is dividing it into
services and components. Hanmer defines them on Page 25[1]:


    1.  COMPONENTS: are the building blocks of the system — the parts of software or the 
        providers of functionality that you combine into your architecture.

    2.  SERVICES: are the things that your components provide to the actors and to one 
        another — the visible functionality of the system. As you divide the functionality 
        of the system into components, you’re also defining what services each component 
        provides. The services can be internal or external to the system.


When designing an application's architecture, Hanmer suggests considering these factors; 
Pg 10[1]:


    ✓ Goals and philosophy of the system: The architecture explains the goals and 
      describes the purpose of the system, as well as who uses it and what problem it 
      solves.

    ✓ Architectural assumptions and dependencies: The architecture explains the 
      assumption made about the environment and about the system itself. The architecture 
      also explains any dependencies on other systems or on the builders of the system.

    ✓ Architecturally significant requirements: The architecture points to the most 
      significant requirements that shaped it.

    ✓ Packaging instructions for subsystems and components: The architecture explains how 
      the parts of the system are deployed on computing platforms and how the parts must 
      be combined for proper functioning. The subsystems and components are the building 
      blocks of the architecture.

    ✓ Critical subsystems and layers: The architecture explains the different views and 
      parts of the system and how they relate. It also explains the most critical 
      subsystems in detail.

    ✓ References to architecturally significant design elements: The architecture 
      describes the most prominent and significant parts of the design. 
      
    ✓ Critical system interfaces: The architecture describes the interfaces of the system, 
      with special attention to the interfaces that are critical to meet the system’s 
      requirements.

    ✓ Key scenarios that describe critical behavior of the system: The architecture
      explains the most important scenarios that illustrate and explain how the system 
      will be used.


2.2 ARCHITECTURAL STYLES

Architectural styles define the general shape of a software system. Hanmer explains the 
concept of architectural styles on Page 25[1]:


    As I mention in Chapter 1, architectural style is like the style of a house. It may 
    define a ranch house, which sprawls horizontally in one story, or a Cape Cod house, 
    which is a two-story structure with a distinctive arrangement of doors and windows 
    on its facade.
    
    In software development, architectural style refers to the general shape of the 
    system. Choosing the appropriate style is important because all the later design 
    decisions are made in the context of this style and in concert with the style. A 
    system may have a streaming style, like Pipes and Filters (see Chapter 10), or it 
    may have an interactive style that’s shaped by Model-View-Controller (MVC; see 
    Chapter 13). The choice of appropriate style is important to your system’s success.


The architectural style of a program determines the choice of the main architectural 
pattern. The next section will introduce the idea of Architectural Styles and their
corresponding Architectural Patterns.


2.3 ARCHITECTURAL PATTERNS

F. Buschmann and company explain the idea of an architectural pattern[]: (Pattern-Oriented Software Architecture, Volume 1 - A System of Patterns (F. Buschmann, H. Rohnert, P. Sommerlad, 1996))

    Abstracting from specific problem-solution pairs and distilling out common factors 
    leads to patterns: These problem-solution pairs tend to fall into families of similar 
    problems and solutions with each family exhibiting a pattern in both the problems and 
    the solutions'. In his book The Timeless Way of Building (Ale791 (p. 247), the 
    architect Christopher Alexander defines the term pattern as follows: 


        Each pattern is a three-part rule, which expresses a relation between a certain 
        context, a problem, and a solution. 

        As an element in the world, each pattern is a relationship between a certain 
        context, a certain system of forces which occurs repeatedly in that context, and 
        a certain spatial configuration which allows these forces to resolve themselves.
        
        As an element of language, a pattern is an instruction, which shows how this 
        spatial configuration can be used, over and over again, to resolve the given 
        system of forces, wherever the context makes it relevant. 

        The pattern is, in short, at the same time a thing, which happens in the world, 
        and the rule which tells us how to create that thing, and when we must create it. 
        It is both a process and a thing: both a description of a thing which is alive, 
        and a description of the process which will generate that thing. We also find 
        many patterns in software architecture. 

        
    Experts in software engineering know these patterns from practical experience and 
    follow them in developing applications with specific properties. They use them to 
    solve design problems both effectively and elegantly.

Architectural patterns are specific expressions of architectural styles. On page 26, 
Hanmer provides a table that lists a few basic architectural styles and their 
corresponding patterns[1]:


    ARCHITECTURAL STYLE         PATTERNS
    From Mud to Structure       Layers (Chapter 9), Pipes and Filters (Chapter 10),
                                Blackboard (Chapter 11)
    Distributed Systems         Broker (Chapter 12)
    Interactive Systems         Model-View-Controller (Chapter 13), Presentation-
                                Abstraction-Control (Chapter 14)
    Adaptable Systems           Microkernel (Chapter 15), Reflection (Chapter 16)


At this point, just note that HRSP uses two architectural styles and their corresponding
patterns:


    Distributed Systems: Client-Server Model
    Interactive Systems: Model-View-Controller


Yes, a project can combine two architectural styles/patterns. These two styles and 
patterns are very common in web world, which is why the rest of the article will explore
these topics in some detail. 


2.4 ENABLING TECHNIQUES

On page 30-31, Hanmer also discusses some enabling techniques that empower the developer to
create good software, independent of architectures and development methodologies[1]:


    ✓ Abstraction: Abstraction is the ability to extract the common, general parts from a 
      particular entity. You use abstraction to define a common component that will be 
      adapted to several specific situations in your system. This technique is exactly what 
      I discuss in the preceding section.

    ✓ Encapsulation: Encapsulation is grouping related elements to preserve the boundaries
      of the abstraction. You use encapsulation to keep related functionality together 
      instead of mixing unrelated functionalities.

    ✓ Information hiding: Information hiding keeps information that clients don’t need 
      to know hidden from them so that it’s protected and the clients don’t misuse it. 
      Encapsulation is frequently used to implement information hiding.

    ✓ Modularization: Modularization handles system complexity by breaking the system 
      into parts with well-defined boundaries. This technique is especially useful as 
      you design software architectures because they frequently are too big to be 
      implemented efficiently as single entities. Modules can contain one or more 
      components, as I talk about elsewhere.

    ✓ Separation of concerns: Within the system, unrelated responsibilities should be 
      separated. You use separation of concerns to define elements that perform specific 
      functions rather than elements that perform a variety of functions.

    ✓ Coupling and cohesion: Coupling is how different modules in the system relate to 
      one another. Cohesion is a measure of how related the objects and functions within 
      a module are to each other. High cohesion and low coupling lead to systems that are 
      easy to modularize and build.

    ✓ Sufficiency and completeness: Every component should be sufficient to include all 
      the characteristics that are needed for useful and efficient interaction with other 
      components. Every component should also capture all the important characteristics
      making it complete.

    ✓ Separation of policy and implementation: Keeping the implementation of algorithms 
      free of system-context-related information simplifies reuse. You use this technique 
      to design parts of the system to deal with contextrelated, or policy, information 
      and other parts to implement abstract algorithms.

    ✓ Separation of interface and implementation: This technique separates the interface 
      that clients use from the implementation of the functionality that the clients expect. 
      It makes reusing the implementation easier and promotes information hiding (discussed 
      earlier in this list).

    ✓ Single point of reference: Avoid inconsistency by defining the items within the 
      software architecture only once. Achieving a single point of reference depends on your 
      programming environment, because some languages, like C++, make achieving this principle 
      difficult. Although C++ also requires a single point of definition, it needs 
      declarations to appear in several places.

    ✓ Divide and conquer: Divide a problem or solution into smaller parts that are easier 
      to solve or implement. You use this technique often as you work with large problems.


The architectural patterns you choose are determined by the enabling technique you want 
to optimize for in your program design. On page 32, Hanmer lists a few more architectural 
patterns, this time in relation to the fundamental techniques they enable[1]:


    ENABLING TECHNIQUE              PATTERN
    Abstraction                     Layers (Chapter 9)
    Encapsulation                   Forwarder-Receiver (Chapter 21)
    Information hiding              Reflection (Chapter 16), Whole-Part (Chapter 17)
    Modularization                  Layers (Chapter 9), Pipes and Filters (Chapter 10), 
                                    Whole-Part (Chapter 17)
    Separation of concerns          Model-View-Controller (Chapter 13)
    Coupling and cohesion           Client-Dispatcher-Server (Chapter 21),  
                                    Publisher-Subscriber (Chapter 21)
    Sufficiency and  
    completeness                    All the patterns (Chapters 9–22)
    Separation of policy and
    implementation                  Strategy*
    Separation of interface
    and implementation              Bridge*
    Single point of 
    reference                       No specific pattern
    Divide and conquer              Microkernel (Chapter 15), Whole-Part (Chapter 17)

* This pattern is available in Design Patterns: Elements of Reusable Object-Oriented 
Software, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides 
(Addison-Wesley Professional).


2.5 LAYERS AND TIERS

There are some fundamental architectural principles which can be used to structure 
software. Instead of developing monolithic applications that are a huge tangled bundle of 
interconnected components, software can be separated into modules, libraries and other
components by using the architectural principles of layers and tiers. 

How do they work?

LAYERS separate software by their function. In a software solution, a developer would find 
software elements with similar or related functions and collect them together, in a few 
files and/or folders. When a collection of similar software elements that are working 
towards the same goal are separated from the main program into dedicated folders and/or 
files, it is called a layer. 

If a project implements the MVC architectural pattern, its functions are separated into
three layers: Models, Views and Controllers. Developers working on an MVC project will 
know that the Controllers folder will contain only controller files, the Models folder 
model class files and the Views folder will hold HTML, CSS and Javascript files. 

Each layer has its own set of responsibilities: The Model layer contains classes that 
define the program's data elements, Views are responsible for displaying information to 
the user and the Controller layer responds to user requests by issuing orders to the other
two layers. Separating software elements with the same goal from the rest of the project 
and concentrating them into layers let's you separate concerns to prevent unneccessary 
entanglements between elements of differing functions and imposes a logical structure on
the project.

TIERS separate software by the hardware platforms to which a software component is to be
deployed. Tiers are a more fundamental form of division than layers. Where layers involve
collecting files with similar functions together into folders, tiers usually break 
software up into separate programs, modules or libraries, depending on where that piece 
of software is going to run. 

For example, let's assume that you have a web application, which has a client-server 
architecture (More on this later.). Such an application is divided itself into two 
parts, the Client and the Server. In this example, there are two tiers, the client, 
which runs on a customer's computer and the Server, which runs on a server machine.


CREATING ABSTRACTION LAYERS USING TIERS AND LAYERS

Hanmer explains how tiers and layers are abstractions. Why do we need abstractions?


    What these different ways of layering the system [Tiers and Layers] have in common is 
    that they’re abstractions. An abstraction is a way of describing something in general 
    terms that leaves out the details of any specific implementation. In the examples in 
    the preceding section, the abstraction is a general layer that doesn’t describe how the 
    functionality is implemented or even precisely what it does; those details are 
    abstracted away.

    ...you see that abstraction is one of the important techniques that help you build 
    better architecture. Abstractions are important to software architecture because they 
    allow you to talk about what the system does in general terms before you’ve worked 
    out all the low-level details. 

    In the same way, the three-tier architecture separates the functionality by 
    abstractly grouping the presentation server and keeping its functionality separate 
    from the functionality of the database servers. This is done because they have 
    different processing or storage needs, and the boundary of an abstraction can be 
    drawn around the layers.

    Being able to abstract the essence of a functionality and project it onto the 
    solution are important skills that you must have as a software architect.


Layers and tiers are used to deliberately create a structure for the project. If this 
is done correctly, changes made to a layer affect only that layer and the same applies to 
tiers. In software projects with no planned architecture, there really isn't any 
structure. In such programs, what should be distinct functions, features, layers and tiers 
are jumbled into a tangled web of code. The architecture of such projects is called a 
'Big Ball of Mud', aka 'Spaghetti Code'. Changing UI code can cause unpredictable failures
in Business Logic or Data Access code. This what happens to a project that does not plan 
out its structure, architecture, architectural style, the specific architectural pattern 
and other such details during the Design phase of the project.


HOW DO LAYERS AND TIERS HELP?

The number of layers and tiers in a software project is variable and depends on the 
project's size and needs, but the number of layers and tiers usually increase with a 
program's size and complexity. 

What's the point of using layers and tiers? Rockford Lhotka explains[3]:

    Why do we layer software? Primarily to gain the benefits of logical organization and 
    grouping of like functionality. Translated to tangible outcomes, logical layers offer 
    reuse, easier maintenance and shorter development cycles. In the final analysis, proper 
    layering of software reduces the cost to develop and maintain an application. Layering 
    is almost always a wonderful thing! 

    Why do we deploy layers onto multiple tiers? Primarily to obtain a balance between 
    performance, scalability, fault tolerance and security. While there are various other 
    reasons for tiers, these four are the most common. The funny thing is that it is almost 
    impossible to get optimum levels of all four attributes – which is why it is always a 
    trade-off between them.

He continues in the article and makes a few practical comments about tiers:

    Tiers imply process and/or network boundaries. A 1-tier model has all the layers running 
    in a single memory space (process) on a single machine. A 2-tier model has some layers
    running in one memory space and other layers in a different memory space. At the very 
    least these memory spaces exist in different processes on the same computer, but more 
    often they are on different computers. Likewise, a 3-tier model has two boundaries. 
    In general terms, an n-tier model has n-1 boundaries.
    
    Crossing a boundary is expensive. It is on the order of 1000 times slower to make a 
    call across a process boundary on the same machine than to make the same call within 
    the same process. If the call is made across a network it is even slower. It is very 
    obvious then, that the more boundaries you have the slower your application will run, 
    because each boundary has a geometric impact on performance.

    Worse, boundaries add raw complexity to software design, network infrastructure, 
    manageability and overall maintainability of a system. In short, the more tiers in an 
    application, the more complexity there is to deal with – which directly increases the 
    cost to build and maintain the application.
    
    This is why, in general terms tiers should be minimized. Tiers are not a good thing, 
    they are a necessary evil required to obtain certain levels of scalability, fault 
    tolerance or security.
    
    As a good architect you should be dragged kicking and screaming into adding tiers to 
    your system. But there really are good arguments and reasons for adding tiers, and 
    it is important to accommodate them as appropriate.
    
    The reality is that almost all systems today are at least 2-tier. Unless you are using 
    an Access or dBase style database your Data layer is running on its own tier – typically 
    inside of SQL Server, Oracle or DB2. So for the remainder of my discussion I’ll primarily 
    focus on whether you should use a 2-tier or 3-tier model...

    ...the question remains whether to configure an application for 2 or 3 tiers. 
    
    Ultimately this question can only be answered by doing a cost-benefit analysis for 
    your particular environment. You need to weigh the additional complexity and cost of 
    a 3-tier deployment against the benefits it might bring in terms of scalability, fault 
    tolerance or security.


HOW LAYERS AND TIERS ARE USED IN APPLICATIONS

This is a diagram of a monolithic application:


+--------------------------------------------------------------------------------------------+
|                                                                                            |
|                                    THE APPLICATION                                         |
|                                                                                            |
|  +--------------------------------------------------------------------+                    |
|  |                                                                    |    +------------+  |
|  |                          APPLICATION COMPONENTS                    |    |            |  |
|  |                                                                    |    |            |  |
|  |   +--------------+       +---------------+     +---------------+   |    |            |  |
|  |   | PRESENTATION | +---> |   BUSINESS    | +-> |  DATA ACCESS  | +----> |  DATABASE  |  |
|  |   |    LAYER     | <---+ |     LAYER     | <-+ |     LAYER     | <----+ |            |  |
|  |   +--------------+       +---------------+     +---------------+   |    |            |  |
|  |                                                                    |    |            |  |
|  |                                                                    |    +------------+  |
|  +--------------------------------------------------------------------+                    |
|                                                                                            |
+--------------------------------------------------------------------------------------------+

                                    RUNS ON A SINGLE MACHINE


To avoid spaghetti code, the program's code has been partitioned into three layers, 
modelled after the layers in N-tier. However, all layers are tightly coupled and live on
the same machine. All three layers are packaged in a single executable and run on the 
same machine. That makes this application's architecture 1-tier.

In such a tightly integrated application, changing one layer will probably require changes 
to the other layers. As the program is designed for a single machine, scaling the number of
processors is probably not possible. For the same reason, the portability factor of this 
design is low. Nevertheless, it may make sense to use this design for small applications
that don't handle much traffic or need much resources.

