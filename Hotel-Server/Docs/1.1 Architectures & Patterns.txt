1. INTRODUCTORY REMARKS: WHY DO WE NEED ARCHITECTURES AND PATTERNS?

Look at the architectural diagram below. It depicts the architecture, or better put, the 
complete lack thereof, in a poorly designed monolithic application.


    +--------------------------------------------------------------------------------------------+
    |                                                                                            |
    |           MONOLITHIC APPLICATION WITH TERRIBLE ARCHITECTURE                                |
    |                                                                                            |
    |  +--------------------------------------------------------------------+                    |
    |  |            +----------+                                            |    +------------+  |
    |  |  PRESENTATION         v                                            |    |            |  |
    |  |     ^ LAYER BUSINESS LOGIC+-----------------------------+          |    |            |  |
    |  |     |       LAYER ^                                     v          |    |            |  |
    |  |     +----------+  |                                DATA ACCESS+-------> |  DATABASE  |  |
    |  |                   |                                   LAYER  <--------+ |            |  |
    |  |                   +-------------------------------------+          |    |            |  |
    |  |                                                                    |    |            |  |
    |  |                                                                    |    +------------+  |
    |  +--------------------------------------------------------------------+                    |
    |                                                                                            |
    +--------------------------------------------------------------------------------------------+

                                      RUNS ON A SINGLE MACHINE


Applications that are poorly designed tend to have their components mixed together into
an incoherent mess. Jason Ables explains the situation[1]:


    Legacy code is software that generates value for a business but is difficult for 
    developers to change. The terms "code rot" and "spaghetti code" refer to legacy code 
    that is tangled up in poor quality. Over time, as "get it done now" is continually 
    favored over "get it done right", the code base decays by avoiding industry best 
    practices, making it tightly coupled, difficult to test, and increasingly prone to 
    defects.

    The longer this goes on, the more frustrated customers get with the software due to 
    quirky defects, bad user experiences and long lead times for changes. Developers are 
    afraid to make changes due to the "Jenga effect" -- as one piece of code is changed 
    or removed, it often leads to new defects being introduced in the system in sometimes 
    seemingly unrelated places. This compounds into what is known as "technical debt".
    
    Just like financial debt, technical debt is sometimes a calculated risk. For example, 
    you may incur technical debt in order to get a software product to market faster. 
    However, just like financial debt, the longer this goes unpaid, especially if it 
    continues to grow, the more it hinders your technical flow. Just like cash flow, 
    technical flow is critical to the health of an organization. Technical flow is the 
    ability for developers to respond quickly to change.


There are many failures that lead to a spaghetti codebase, and this article will discuss
mitigating technical debt through the use of Architectural Patterns and sound 
Architectural Design Principles (which are also called Enabling Techniques). 

At the start of every project, the developer (team) needs to carefully choose 
architectural patterns for it. The architectural styles, patterns and design principles 
used to structure a project will in large part determine its future quality. A program 
with a good design will have built-in resistance to code rot.  

Web projects like the Hotel-Reservation-System Project (HRSP) are structured into 
sub-components by implementing certain architecture styles and patterns. Dividing code 
into clearly demarcated modules has been found to make programs simpler to develop, 
maintain and extend, and easier to debug. Modules should not directly depend on the 
internals of other modules, but rather, every layer/tier should define and expose public 
interfaces. By doing this, layers and tiers are loosely coupled, easily modified or
swapped out for replacements. 

First, in Section 2, basic architectural concepts will be discussed:


    2.1 Introduction to Software Architectures
    2.2 Architectural Styles
    2.3 Architectural Patterns
    2.4 Enabling Techniques
    2.5 Practical Architectural Principles: Layers and Tiers
    
    
Then, in Section 3, these principles and techniques will be applied to create multi-layer
and multi-tier software. The next article, '1.2 Distributed Computing Architectures', 
will discuss specific architectures such as the Client-Server and Multi-tier as well as
the MVC architectural pattern.


2.1 AN INTRODUCTION TO SOFTWARE ARCHITECTURES

In Robert Hanmer's book 'Pattern-Oriented Software Architecture For Dummies', he offers a 
simple definition of the term Software Architecture on Page 9[2]:


    Every system has an architecture — some high-level structure that underlies the whole 
    system. Software architecture is how the pieces fit together to build the solution to 
    some business or technical need that your customer or client wants solved. The 
    architecture has a purpose.
    
    The decisions made during the creation of the architecture are truly fundamental to 
    the system because they set the stage for all the other decisions that will come 
    later.


Here's a more elaborate definition[3]: 

    An architecture embodies information about components and their interaction, but 
    omits information about components that does not pertain to their interaction. Thus, 
    an architecture is foremost an abstraction of a system that suppresses details of 
    components that do not affect the use, the relations and interactions of components. 
    Private details of components, details that have to do solely with internal 
    implementation and are not externally visible, are not architectural. In short, an 
    architecture determines how components interact, not how they are implemented.


Here's a third definition that explains another aspect of architectures[4]: 

    Software architecture encompasses the set of significant decisions about the 
    organization of a software system including the selection of the structural elements 
    and their interfaces by which the system is composed; behavior as specified in 
    collaboration among those elements; composition of these structural and behavioral 
    elements into larger subsystems; and an architectural style that guides this 
    organization. Software architecture also involves functionality, usability, 
    resilience, performance, reuse, comprehensibility, economic and technology 
    constraints, tradeoffs and aesthetic concerns.


To reiterate, it's critical to think through the architecture of your program before 
writing the first line of code. Spend a lot of time designing the architecture, because 
it sets the tone for how your project will turn out.


2.1.1 PARTS OF AN ARCHITECTURE

When a programmer designs a software solution's architecture, she is dividing it into
Services and Components. Hanmer defines them on Page 25[2]:


    1.  COMPONENTS: are the building blocks of the system — the parts of software or the 
        providers of functionality that you combine into your architecture.

    2.  SERVICES: are the things that your components provide to the actors and to one 
        another — the visible functionality of the system. As you divide the functionality 
        of the system into components, you’re also defining what services each component 
        provides. The services can be internal or external to the system.


As you plan your architecture, you will need to break up your application into various
components - libraries, modules, layers, tiers, sub-programs. Keep track of these 
components, along with the services that they provide to other components. 


2.1.2 BEST PRACTICES AND FACTORS OF ARCHITECTURE DESIGN

When designing an application's architecture, Hanmer suggests considering these factors; 
Pg 10[2]:


    ✓ Goals and philosophy of the system: The architecture explains the goals and 
      describes the purpose of the system, as well as who uses it and what problem it 
      solves.

    ✓ Architectural assumptions and dependencies: The architecture explains the 
      assumption made about the environment and about the system itself. The architecture 
      also explains any dependencies on other systems or on the builders of the system.

    ✓ Architecturally significant requirements: The architecture points to the most 
      significant requirements that shaped it.

    ✓ Packaging instructions for subsystems and components: The architecture explains how 
      the parts of the system are deployed on computing platforms and how the parts must 
      be combined for proper functioning. The subsystems and components are the building 
      blocks of the architecture.

    ✓ Critical subsystems and layers: The architecture explains the different views and 
      parts of the system and how they relate. It also explains the most critical 
      subsystems in detail.

    ✓ References to architecturally significant design elements: The architecture 
      describes the most prominent and significant parts of the design. 
      
    ✓ Critical system interfaces: The architecture describes the interfaces of the system, 
      with special attention to the interfaces that are critical to meet the system’s 
      requirements.

    ✓ Key scenarios that describe critical behavior of the system: The architecture
      explains the most important scenarios that illustrate and explain how the system 
      will be used.


These are some best practices to follow when designing your architecture[5]: 


    Best Practices in Software Architecture
    There are a number of principles on which a good software architecture is anchored:
    
        * Instead of being built to last, it is built to change.

        * Before any components can be designed, the software architect must clearly 
          understand the needs of the user and the domain.

        * The software architect must identify the subsystems in the product after which
          he should consider components and layers and abstract them so as to identify 
          every key interface therein.

        * Using an iterative and incremental approach to designing the software 
          architecture is a great idea.  

        * Use lessons learned from history, record every decision you make and 
          conclusively mitigate major risks.

        * Underinvesting in software architecture is not an option.


2.2 ARCHITECTURAL STYLES

Architectural styles define the general shape of a software system. Hanmer explains the 
concept of architectural styles on Page 25[2]:


    As I mention in Chapter 1, architectural style is like the style of a house. It may 
    define a ranch house, which sprawls horizontally in one story, or a Cape Cod house, 
    which is a two-story structure with a distinctive arrangement of doors and windows 
    on its façade.
    
    In software development, architectural style refers to the general shape of the 
    system. Choosing the appropriate style is important because all the later design 
    decisions are made in the context of this style and in concert with the style. A 
    system may have a streaming style, like Pipes and Filters (see Chapter 10), or it 
    may have an interactive style that’s shaped by Model-View-Controller (MVC; see 
    Chapter 13). The choice of appropriate style is important to your system’s success.


The architectural style of a program determines the choice of the main architectural 
pattern. The next section will introduce the idea of Architectural Styles and their
corresponding Architectural Patterns.


2.3 ARCHITECTURAL PATTERNS

F. Buschmann and company explain the idea of an architectural pattern[6]:

    Abstracting from specific problem-solution pairs and distilling out common factors 
    leads to patterns: These problem-solution pairs tend to fall into families of similar 
    problems and solutions with each family exhibiting a pattern in both the problems and 
    the solutions'. In his book The Timeless Way of Building (Ale791 (p. 247), the 
    architect Christopher Alexander defines the term pattern as follows: 


        Each pattern is a three-part rule, which expresses a relation between a certain 
        context, a problem, and a solution. 

        As an element in the world, each pattern is a relationship between a certain 
        context, a certain system of forces which occurs repeatedly in that context, and 
        a certain spatial configuration which allows these forces to resolve themselves.
        
        As an element of language, a pattern is an instruction, which shows how this 
        spatial configuration can be used, over and over again, to resolve the given 
        system of forces, wherever the context makes it relevant. 

        The pattern is, in short, at the same time a thing, which happens in the world, 
        and the rule which tells us how to create that thing, and when we must create it. 
        It is both a process and a thing: both a description of a thing which is alive, 
        and a description of the process which will generate that thing. We also find 
        many patterns in software architecture. 

        
    Experts in software engineering know these patterns from practical experience and 
    follow them in developing applications with specific properties. They use them to 
    solve design problems both effectively and elegantly.

Architectural patterns are specific expressions of architectural styles. On page 26, 
Hanmer provides a table that lists a few basic architectural styles and their 
corresponding patterns[2]:


    ARCHITECTURAL STYLE         PATTERNS
    From Mud to Structure       Layers (Chapter 9), Pipes and Filters (Chapter 10),
                                Blackboard (Chapter 11)
    Distributed Systems         Broker (Chapter 12)
    Interactive Systems         Model-View-Controller (Chapter 13), Presentation-
                                Abstraction-Control (Chapter 14)
    Adaptable Systems           Microkernel (Chapter 15), Reflection (Chapter 16)


At this point, just note that HRSP uses two architectural styles and their corresponding
patterns:


    Distributed Systems: Client-Server Model
    Interactive Systems: Model-View-Controller


Yes, a project can combine two architectural styles/patterns. These two styles and 
patterns are very common in web world, which is why the following articles will explore
these topics in some detail. 


2.4 ENABLING TECHNIQUES

On page 30-31, Hanmer also discusses some enabling techniques that empower the developer to
create good software, independent of architectures and development methodologies[2]:


    ✓ Abstraction: Abstraction is the ability to extract the common, general parts from a 
      particular entity. You use abstraction to define a common component that will be 
      adapted to several specific situations in your system. This technique is exactly what 
      I discuss in the preceding section.

    ✓ Encapsulation: Encapsulation is grouping related elements to preserve the boundaries
      of the abstraction. You use encapsulation to keep related functionality together 
      instead of mixing unrelated functionalities.

    ✓ Information hiding: Information hiding keeps information that clients don’t need 
      to know hidden from them so that it’s protected and the clients don’t misuse it. 
      Encapsulation is frequently used to implement information hiding.

    ✓ Modularization: Modularization handles system complexity by breaking the system 
      into parts with well-defined boundaries. This technique is especially useful as 
      you design software architectures because they frequently are too big to be 
      implemented efficiently as single entities. Modules can contain one or more 
      components, as I talk about elsewhere.

    ✓ Separation of concerns: Within the system, unrelated responsibilities should be 
      separated. You use separation of concerns to define elements that perform specific 
      functions rather than elements that perform a variety of functions.

    ✓ Coupling and cohesion: Coupling is how different modules in the system relate to 
      one another. Cohesion is a measure of how related the objects and functions within 
      a module are to each other. High cohesion and low coupling lead to systems that are 
      easy to modularize and build.

    ✓ Sufficiency and completeness: Every component should be sufficient to include all 
      the characteristics that are needed for useful and efficient interaction with other 
      components. Every component should also capture all the important characteristics
      making it complete.

    ✓ Separation of policy and implementation: Keeping the implementation of algorithms 
      free of system-context-related information simplifies reuse. You use this technique 
      to design parts of the system to deal with context related, or policy, information 
      and other parts to implement abstract algorithms.

    ✓ Separation of interface and implementation: This technique separates the interface 
      that clients use from the implementation of the functionality that the clients expect. 
      It makes reusing the implementation easier and promotes information hiding (discussed 
      earlier in this list).

    ✓ Single point of reference: Avoid inconsistency by defining the items within the 
      software architecture only once. Achieving a single point of reference depends on your 
      programming environment, because some languages, like C++, make achieving this principle 
      difficult. Although C++ also requires a single point of definition, it needs 
      declarations to appear in several places.

    ✓ Divide and conquer: Divide a problem or solution into smaller parts that are easier 
      to solve or implement. You use this technique often as you work with large problems.


The architectural patterns you choose are determined by the enabling technique you want 
to optimize for in your program design. On page 32, Hanmer lists a few more architectural 
patterns, this time in relation to the fundamental techniques they enable[2]:


    ENABLING TECHNIQUE              PATTERN
    Abstraction                     Layers (Chapter 9)
    Encapsulation                   Forwarder-Receiver (Chapter 21)
    Information hiding              Reflection (Chapter 16), Whole-Part (Chapter 17)
    Modularization                  Layers (Chapter 9), Pipes and Filters (Chapter 10), 
                                    Whole-Part (Chapter 17)
    Separation of concerns          Model-View-Controller (Chapter 13)
    Coupling and cohesion           Client-Dispatcher-Server (Chapter 21),  
                                    Publisher-Subscriber (Chapter 21)
    Sufficiency and  
    completeness                    All the patterns (Chapters 9–22)
    Separation of policy and
    implementation                  Strategy*
    Separation of interface
    and implementation              Bridge*
    Single point of 
    reference                       No specific pattern
    Divide and conquer              Microkernel (Chapter 15), Whole-Part (Chapter 17)

* This pattern is available in Design Patterns: Elements of Reusable Object-Oriented 
Software, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides 
(Addison-Wesley Professional).


2.4.1 USING ENABLING TECHNIQUES

Section 2.4 listed a lot of enabling techniques. How can you use them?

Well, the first thing you might want to use is the Divide and Conquer technique to
break up your big software problem into smaller ones. When you start designing your
program's architecture, it's a big problem in your head and it's probably fuzzy and 
somewhat incoherent. DIVIDE AND CONQUER helps you to break up the solution into 
components. You can divide you components into interfaces and classes. 

You should enforce the SEPARATION OF INTERFACE AND IMPLEMENTATION by using interfaces
to connect components together. This prevents a component from being dependent on 
another component's internals. This is one way to enforce LOOSE COUPLING and also helps
with MODULARIZATION. 


2.4.2 PACKAGING PRINCIPLES: HIGH COHESION AND LOOSE COUPLING

The definitions for cohesion and coupling are taken from this StackOverflow question[7]: 

Cohesion is concerned with members WITHIN a particular module or class. COHESION refers 
to the degree to which the members of a module or class belong together. Ideally, when 
you put elements into a module/class, they should be very closely related to each other. 
A module with members that are very closely related is said to be HIGHLY COHESIVE. There 
are several kinds of cohesion, but the best kind is functional cohesion, i.e. the members 
are put into a module because they all contribute to main task of the module. That task
should be well-defined. High cohesion is the opposite of Low cohesion. 

COUPLING is concerned with the relationship BETWEEN modules/classes. It refers to the 
degree to which modules or classes depend on each other. Ideally, there should be as 
little dependency between modules and classes as possible, because this makes it easy to 
change or swap out a module/class without causing unrelated effects in the rest of the 
program. This ideal level of dependency is called LOOSE COUPLING. A loosely coupled 
system is one in which each of its components has little or no knowledge of the internal 
implementation details of other components. In such a system, different modules, 
components and classes are as independent as possible from other components. Loose 
coupling is the opposite of tight coupling. In a tightly coupled system, components are 
so tied together that changing one component will require changing the other.

In software architectures, it's a good idea for components to be HIGHLY COHESIVE AND 
LOOSELY COUPLED. As Hanmer noted, "High cohesion and low coupling lead to systems that 
are easy to modularize and build." In architectures that suffer from low cohesion or tight
coupling or both, components tend to too interdependent. Changing one component tends to 
cause bugs or behavioural changes in other components. If you recall, this is a telltale 
sign of a spaghetti codebase. When you design a program's architecture, you will want to 
choose loose coupling between components and high cohesion within a component. 

Think of how to design a class with high cohesion and low coupling. A class ought to have
a single goal. Some of its members are public and others private. You have to use 
ENCAPSULATION to group related related information together in that class. If all the 
members of the class are closely related and work towards the same goal, the class can be
said to be HIGHLY COHESIVE. With the use of INFORMATION HIDING, you can shield the 
class's internal implementation from external actors. Public properties and methods 
abstract away implementation details and expose only members the consumer needs to know. 
In other words, the public members of a class comprise an ABSTRACTION LAYER that 
conceals irrelevant details. All of these things together help to MODULARIZE a class from
other classes so that there is a SEPARATION OF CONCERNS. 

If these techniques are applied at the architectural level, you can achieve the same 
effect. Putting all related members in specialized modules and designing the modules to 
have as little dependency on each other as possible lets the systems designer build an 
architecture that be changed easily in response to business requirements. Loose coupling
even lets you work on modules independently. 


2.5.1 ORGANIZING SMALL PROJECTS USING FOLDERS

Thus far, this article has been very abstract. Let's move on to the practical part; how
are these principles applied to a software project? 

Let's start with the simplest possible ASP.NET Core program: one with a single project in 
it. Such a program is called a monolithic application. Steve Smith defines it on page 21 
of his book[8]:


    A monolithic application is one that is entirely self-contained, in terms of its 
    behavior. It may interact with other services or data stores in the course of 
    performing its operations, but the core of its behavior runs within its own process 
    and the entire application is typically deployed as a single unit. If such an 
    application needs to scale horizontally, typically the entire application is 
    duplicated across multiple servers or virtual machines... The smallest possible 
    number of projects for an application architecture is one. In this architecture, the
    entire logic of the application is contained in a single project, compiled to a 
    single assembly, and deployed as a single unit. 
     
     
Even in such a small program, one should take care to organize code to avoid a descent
into spaghetti code. The simplest way to organize code is to collect software elements 
with similar or related functions and to store them together in their own folders. In 
ASP.NET Core, it is traditional to have these folders: 


    1. Data: Any code related to a database, data store or other related functions like 
       migrations, should stored in this folder. If your project uses migrations, the 
       Data folder should have a dedicated Migrations folder to store them. 
       
    2. Services: Microsoft Docs defines a service as "A service is a component that's 
       intended for common consumption in an app. Services are made available through 
       dependency injection (DI). ASP.NET Core includes a native Inversion of Control 
       (IoC) container that supports constructor injection by default. You can replace 
       the default container if you wish. In addition to its loose coupling benefit, DI 
       makes services, such as logging, available throughout your app." Much of the 
       business logic for your program should be put into this folder.  
       
    3. Models: This folder will store POCO classes which define business entities for 
       your project. 
           
    4. Views: This folder will contain presentation logic for your application. This 
       will typically be HTML, CSS, and Javascript in ASP.NET Core projects, but your
       application can also use a text UI, a GUI library and in the future, potentially
       frameworks like the C#/HTML based Blazor.   
       
    5. Controllers: This folder will contain controllers, which are the brains of most
       web applications. 


Using folders to group like classes and interfaces together helps to enforce separation
of concerns at the single-project scenario level. But once the program reaches a certain 
size, using folders alone to separate concerns no longer works. 

Steve Smith explains the problems that arise when your monolithic application becomes too
complex (page 22)[8]:


    Although simple, the single-project monolithic solution has some disadvantages. As 
    the project’s size and complexity grows, the number of files and folders will continue 
    to grow as well. User Interface (UIconcerns (models, views, controllers) reside in 
    multiple folders, which are not grouped together alphabetically. This issue only gets 
    worse when additional UI-level constructs, such as Filters or ModelBinders, are added 
    in their own folders. Business logic is scattered between the Models and Services 
    folders, and there’s no clear indication of which classes in which folders should 
    depend on which others. This lack of organization at the project level frequently 
    leads to spaghetti code. 
    
    To address these issues, applications often evolve into multi-project solutions, 
    where each project is considered to reside in a particular layer of the application.  


The next few sections will discuss using layers and tiers to manage mid-size and large
applications. 


2.5.2 ORGANIZING MEDIUM-SIZED AND LARGE APPLICATIONS INTO LAYERS USING PROJECTS

Layers and tiers are how Architectural Principles (Enabling Techniques) are applied to 
create good architectures. How do they work?

LAYERS are an extension of the concept of using folders. They separate software by their 
function into separate projects. When a collection of similar software elements that are 
working towards the same goal are separated from the main program into their own dedicated 
project, it is called a layer. A multi-layer program is the combination of two or more 
projects. 

In a software solution that's grown too complex, a developer should first study its 
current structure. Which parts of the program are the problem? Which folders have grown 
too complicated? The most complex folders should be moved into their own projects. 

In the programming world, there is the tradition of the N-Layer architecture. N-Layer
architecture has the following THREE layers:


    1. User Interface Layer (UI): This project should contain the Presentation logic for
       your program. (Microsoft Docs suggests calling this project 'Web'. This makes 
       sense because the frontend in ASP.NET Core projects are usually written in HTML, 
       CSS and Javascript and sent to the client's browser. If that's so, the 'View' 
       folder from your program should be moved into the UI project.)
    
    2. Business Logic Layer (BLL): This project should contain the Business logic for 
       your program. (Microsoft Docs call this project 'ApplicationCore'. This project
       should hold the 'Controllers', 'Models' and 'Services' folders.)
    
    3. Data Access Layer (DAL): This project should contain the Data Access logic for 
       your program. (Microsoft Docs calls this the 'Infrastructure' project, and it 
       should hold the 'Data' folder and its contents, including the 'Migrations' 
       folder.)
       
 
A very large and complex application could have even more layers. On page 24, Steve Smith
explains the functions of these layers and their interrelationships[8]:


    Using this architecture, users make requests through the UI layer, which interacts 
    only with the BLL. The BLL, in turn, can call the DAL for data access requests. The 
    UI layer shouldn’t make any requests to the DAL directly, nor should it interact with 
    persistence directly through other means. Likewise, the BLL should only interact with 
    persistence by going through the DAL. In this way, each layer has its own well-known 
    responsibility. 
    
    One disadvantage of this traditional layering approach is that compile-time 
    dependencies run from the top to the bottom. That is, the UI layer depends on the BLL, 
    which depends on the DAL. This means that the BLL, which usually holds the most 
    important logic in the application, is dependent on data access implementation details 
    (and often on the existence of a database). Testing business logic in such an 
    architecture is often difficult, requiring a test database. The dependency inversion 
    principle can be used to address this issue, as you’ll see in the next section. 
       
       
Each layer has its own set of responsibilities and only the files and folders that 
contribute to those ends should be included in that layer's project. Separating software 
elements with the same goal from the rest of the project and concentrating them into 
layers let's you enforce separation of concerns to prevent unnecessary entanglements 
between elements of differing functions and imposes a logical structure on the project.
The act of creating layers should bring the idea of cohesion to mind: gathering together 
like elements and consolidating them in one project increases cohesion in that layer. 
Thus, creating good quality layers brings high cohesion to your module/library/sub-program. 

Before continuing to the subject of tiers, I want to mention the solution to the problem
that Smith refers to in the second paragraph. Steve Smith calls it 'Clean Architecture'
on page 28-29[8]:


    Applications that follow the Dependency Inversion Principle as well as the 
    Domain-Driven Design (DDD) principles tend to arrive at a similar architecture. This 
    architecture has gone by many names over the years. One of the first names was 
    Hexagonal Architecture, followed by Ports-and-Adapters. More recently, it’s been cited
    as the Onion Architecture or Clean Architecture. The most recent name, Clean 
    Architecture, is used to describe this architecture in this e-book. 
    
    Note: The term Clean Architecture can be applied to applications that are built using 
    DDD Principles as well as to those that are not built using DDD. In the case of the 
    former, this combination may be referred to as “Clean DDD Architecture”. 
    
    Clean architecture puts the business logic and application model at the center of the 
    application. Instead of having business logic depend on data access or other 
    infrastructure concerns, this dependency is inverted: infrastructure and 
    implementation details depend on the Application Core. This is achieved by defining 
    abstractions, or interfaces, in the Application Core, which are then implemented by 
    types defined in the Infrastructure layer. A common way of visualizing this
    architecture is to use a series of concentric circles, similar to an onion... [See
    page 29 of this book for an image of this architecture.]
    
    In this diagram, dependencies flow toward the innermost circle. The Application Core 
    takes its name from its position at the core of this diagram. It has no dependencies 
    on other application layers. The application’s entities and interfaces are at the 
    very center. Just outside, but still in the Application Core, are domain services, 
    which typically implement interfaces defined in the inner circle. Outside of the 
    Application Core, both the UI and the Infrastructure layers depend on the Application 
    Core, but not on one another (necessarily). 
    

On page 30, Smith explains how layers should apply the principle of 'Separation of 
interface and implementation' to prevent layers from being tightly-coupled to other
layers[8]: 

    
    With the clean architecture, the UI layer works with interfaces defined in the 
    Application Core at compile time, and ideally shouldn’t know about the implementation 
    types defined in the Infrastructure layer. At run time, however, these implementation 
    types are required for the app to execute, so they need to be present and wired up to 
    the Application Core interfaces via dependency injection.  


2.5.3 CREATING MULTI-PART SOFTWARE PROGRAMS USING TIERS

TIERS separate software by the hardware platforms to which a software component is to be
deployed. Tiers are a more fundamental form of division than layers. Where creating a 
layer involves collecting files and folders with similar functions together into a 
project, tiers usually break software up into separate programs, modules or libraries, 
depending on where that piece of software is going to run. 

Tiers help to avoid a spaghetti architecture, because the act of designing software for
a tier requires severing the whole into independent parts. You have to decide the 
hardware platforms where you want each software component to execute. With this in mind,
if your program is not already divided into projects, that has to be done. 

The creation of tiers should bring the concept of coupling to mind. A multitier 
architecture decreases coupling in your application. Hence, the use of tiers in your 
program architecture helps to bring a degree of loose coupling to your program. 

For example, let's assume that you have a web application, which has a client-server 
architecture (More on this in the next article.). Such an application is divided itself
into two parts, the Client and the Server. In this example, there are two tiers, the 
Client, which runs on a customer's computer and the Server, which runs on a server 
machine.


2.5.4 WHAT DO LAYERS AND TIERS DO FOR YOUR APPLICATION?

The number of layers and tiers in a software project is variable and depends on the 
project's size and needs, but the number of layers and tiers usually increase with a 
program's size and complexity. 

What's the point of using layers and tiers? Rockford Lhotka explains[9]:


    Why do we layer software? Primarily to gain the benefits of logical organization and 
    grouping of like functionality. Translated to tangible outcomes, logical layers offer 
    reuse, easier maintenance and shorter development cycles. In the final analysis, proper 
    layering of software reduces the cost to develop and maintain an application. Layering 
    is almost always a wonderful thing! 

    Why do we deploy layers onto multiple tiers? Primarily to obtain a balance between 
    performance, scalability, fault tolerance and security. While there are various other 
    reasons for tiers, these four are the most common. The funny thing is that it is almost 
    impossible to get optimum levels of all four attributes – which is why it is always a 
    trade-off between them.


He continues on and later in the article, he makes a few practical comments about tiers:


    Tiers imply process and/or network boundaries. A 1-tier model has all the layers running 
    in a single memory space (process) on a single machine. A 2-tier model has some layers
    running in one memory space and other layers in a different memory space. At the very 
    least these memory spaces exist in different processes on the same computer, but more 
    often they are on different computers. Likewise, a 3-tier model has two boundaries. 
    In general terms, an n-tier model has n-1 boundaries.
    
    Crossing a boundary is expensive. It is on the order of 1000 times slower to make a 
    call across a process boundary on the same machine than to make the same call within 
    the same process. If the call is made across a network it is even slower. It is very 
    obvious then, that the more boundaries you have the slower your application will run, 
    because each boundary has a geometric impact on performance.

    Worse, boundaries add raw complexity to software design, network infrastructure, 
    manageability and overall maintainability of a system. In short, the more tiers in an 
    application, the more complexity there is to deal with – which directly increases the 
    cost to build and maintain the application.
    
    This is why, in general terms tiers should be minimized. Tiers are not a good thing, 
    they are a necessary evil required to obtain certain levels of scalability, fault 
    tolerance or security.
    
    As a good architect you should be dragged kicking and screaming into adding tiers to 
    your system. But there really are good arguments and reasons for adding tiers, and 
    it is important to accommodate them as appropriate.
    
    The reality is that almost all systems today are at least 2-tier. Unless you are using 
    an Access or dBase style database your Data layer is running on its own tier – typically 
    inside of SQL Server, Oracle or DB2. So for the remainder of my discussion I’ll primarily 
    focus on whether you should use a 2-tier or 3-tier model...

    ...the question remains whether to configure an application for 2 or 3 tiers. 
    
    Ultimately this question can only be answered by doing a cost-benefit analysis for 
    your particular environment. You need to weigh the additional complexity and cost of 
    a 3-tier deployment against the benefits it might bring in terms of scalability, fault 
    tolerance or security.


2.5.5 CREATING ABSTRACTION LAYERS USING TIERS AND LAYERS

In section 2.5.1, it was established that layers bring high cohesion to your application,
while tiers bring loose coupling. I provided some discussion on the benefits they bring to 
your application, but I want to bring up the concept of abstraction and abstraction layers. 
Layers and tiers are used to create abstraction layers in your application, which in turn 
bring the aforementioned benefits. 

Hanmer explains how tiers and layers are used to create abstraction layers in your 
application[2]:


    What these different ways of layering the system [Tiers and Layers] have in common is 
    that they’re abstractions. An abstraction is a way of describing something in general 
    terms that leaves out the details of any specific implementation. In the examples in 
    the preceding section, the abstraction is a general layer that doesn’t describe how 
    the functionality is implemented or even precisely what it does; those details are 
    abstracted away.

    ...you see that abstraction is one of the important techniques that help you build 
    better architecture. Abstractions are important to software architecture because they 
    allow you to talk about what the system does in general terms before you’ve worked 
    out all the low-level details. 

    In the same way, the three-tier architecture separates the functionality by 
    abstractly grouping the presentation server and keeping its functionality separate 
    from the functionality of the database servers. This is done because they have 
    different processing or storage needs, and the boundary of an abstraction can be 
    drawn around the layers.

    Being able to abstract the essence of a functionality and project it onto the 
    solution are important skills that you must have as a software architect.


Before getting into Abstraction Layers, let's take a closer look at the definition of 
Abstraction again. Hanmer defines Abstraction on Page 30[2]:


    Abstraction is the ability to extract the common, general parts from a particular 
    entity. You use abstraction to define a common component that will be adapted to 
    several specific situations in your system.


From this idea, comes the concept of abstraction layers. The Wikipedia article on 
Abstraction Layer explains it as follows[10]: 


    In computing, an abstraction layer or abstraction level is a way of hiding the 
    implementation details of a particular set of functionality, allowing the separation 
    of concerns to facilitate interoperability and platform independence. Examples of 
    software models that use layers of abstraction include the OSI model for network 
    protocols, OpenGL and other graphics libraries.
    
    In computer science, an abstraction layer is a generalization of a conceptual model 
    or algorithm, away from any specific implementation. These generalizations arise from
    broad similarities that are best encapsulated by models that express similarities 
    present in various specific implementations. The simplification provided by a good 
    abstraction layer allows for easy reuse by distilling a useful concept or design 
    pattern so that situations where it may be accurately applied can be quickly 
    recognized.
    
    A layer is considered to be on top of another if it depends on it. Every layer can 
    exist without the layers above it, and requires the layers below it to function. 
    Frequently abstraction layers can be composed into a hierarchy of abstraction levels. 
    The OSI model comprises seven abstraction layers. Each layer of the model 
    encapsulates and addresses a different part of the needs of digital communications, 
    thereby reducing the complexity of the associated engineering solutions. 


Layers and tiers are used to deliberately create a architecture for the project by 
cutting up the project into meaningful components. Creating components is an opportunity 
increase cohesion of separate concerns by collecting together like software elements into 
projects. You can also deploy the concepts of encapsulation, information hiding and 
abstraction to create black box components that conceal implementation details of a layer
while exposing official interfaces. 

A layer designed in this manner exposes official interfaces through an abstraction 
layer. Doing this decreases the chances of other modules using the internal 
implementations of a module. This should help to create a system with loose coupling
between modules and sub-programs. The application of all these sound architectural 
principles will take your project on a direction that leads away from spaghetti 
codebases.

What does an abstraction layer look like in practice? In a StackOverflow answer, gb2d 
offers a concrete example of an abstraction layer[11]:


    Often an abstraction layer is commonly used to 'abstract' away detail.
    
    Say you had a program for moving money around between different banks. There is a 
    function for moving money to BankA, and a different function for moving money to 
    BankB and so on. The different functions might exist because the information that 
    different banks request varies (As a simple example maybe one requests the senders 
    first name and surname, and another requests the senders first initial and surname).

    Your functions might be:

    
        MoveMoneyToBankA(amount, accountNo, senderFirstName, senderSurname)
        {
            ... Code to move money to bank A
        }
        
        MoveMoneyToBankB(amount, accountNo, senderFirstInitial, senderSurname)
        { 
            ... Code to move money to bank A
        }


    To abstract away all the different things a program needs to think about when 
    communicating with different banks, an abstration layer might be implemented by 
    adding the function 'MoveMoneyToBank':
    
    
        MoveMoneyToBank(amount, accountNo, senderFirstName, senderSurname, bankName)
        {   
            ... If bank name = 'BankA' call MoveMoneyToBankA
            ... If bank name = 'BankB', find senderFirstInitial using senderFirstName, 
                and call 'MoveMoneyToBankB'
        }


    So what you have done here is abstracted away the detail that needs to be managed 
    when communicating with two different banks. A programmer can now just use the 
    general MoveMoneyToBank function, and not have to think about the different 
    requirements of each bank.
    
    In reality, this might not just be functions with in the same program, but even 
    different projects within the same solution, or a new software project that draws in 
    lots of components and deals with the complexity of working with all the separate 
    components to achieve a common goal.


3. A BETTER DESIGNED ARCHITECTURE

Finally, let's take a look at diagrams of a better designed application. Contrasted with
the mess from section 1, this is a diagram of a monolithic application with layers that 
successfully separate concerns:


+--------------------------------------------------------------------------------------------+
|                                                                                            |
|                                    THE APPLICATION                                         |
|                                                                                            |
|  +--------------------------------------------------------------------+                    |
|  |                                                                    |    +------------+  |
|  |                          APPLICATION COMPONENTS                    |    |            |  |
|  |                                                                    |    |            |  |
|  |   +--------------+       +---------------+     +---------------+   |    |            |  |
|  |   | PRESENTATION | +---> |   BUSINESS    | +-> |  DATA ACCESS  | +----> |  DATABASE  |  |
|  |   |    LAYER     | <---+ |     LAYER     | <-+ |     LAYER     | <----+ |            |  |
|  |   +--------------+       +---------------+     +---------------+   |    |            |  |
|  |                                                                    |    |            |  |
|  |                                                                    |    +------------+  |
|  +--------------------------------------------------------------------+                    |
|                                                                                            |
+--------------------------------------------------------------------------------------------+

                                    RUNS ON A SINGLE MACHINE


To avoid spaghetti code, the program's code has been partitioned into three distinct 
layers, modelled after the layers in N-tier architecture. However, once the program gets
big enough, it probably will not be modular enough, because all the layers run on the 
same machine. 

It also limits this program to being a 1-tier architecture. That means that all three 
layers are packaged in a single executable and run on the same machine. The absence of 
tiers means that is program's architecture is probably tightly coupled. (Unless the 
design exposes interfaces for each layer.) In such a tightly integrated application, 
changing one layer will probably require changes to the other layers. As the program is 
designed for a single machine, scaling the number of processors is probably not possible. 
For the same reason, the portability factor of this design is low. Nevertheless, it may 
make sense to use this design for small applications that don't handle much traffic or 
need much resources.

How can this design be improved? It uses layers, but not tiers. If the design calls for
it, I could try adding tiers:


+------------------------------------------------+ +-----------------------------------------+
|                CLIENT APPLICATION              | |          SERVER-SIDE APPLICATION        |
|                                                | |                                         |
| +--------------------------------------------+ | | +---------------------+                 |
| |              ABSTRACTION LAYER             | | | |  DATA ACCESS LAYER  |  +------------+ |
| |                                            | | | |                     |  |            | |
| | +----------------+      +----------------+ | | | |  +---------------+  |  |            | |
| | |  PRESENTATION  | +--> |    BUSINESS    | +------> |  DATA ACCESS  | +-> |  DATABASE  | |
| | |     LAYER      | <--+ |     LAYER      | <------+ |     LAYER     | <-+ |            | |
| | +----------------+      +----------------+ | | | |  +---------------+  |  |            | |
| |                                            | | | |                     |  +------------+ |
| +--------------------------------------------+ | | +---------------------+                 |
+------------------------------------------------+ +-----------------------------------------+

        RUNS ON USER'S PC OR WEB SERVER                RUNS ON APPLICATION/DATABASE SERVER


In this variation of the 2-tier architecture, the Presentation and Business Logic layers 
are combined into the client. The client would probably run on a user's machine while the 
Data Access Layer and the Database live on a server. Another variation of this design 
would bundle the Business Logic and Data Access layers together. 

This application is less tightly coupled than the 1-tier application, so making changes 
like swapping out the database become easier. The Presentation and Business Logic layers 
are still coupled, making it likely that any changes to one layer could affect the other. 

In a 3-tier application, you would have, three programs running on three different 
machines: a client application running on the user's PC or perhaps on a web server, an 
App server program (containing the Business Logic Layer and DAL) running on an 
Application Server, and the Database backend will run on a Database Server:


+--------------------+  +-------------------------------------------+  +----------------------+
| CLIENT APPLICATION |  |             APP SERVER/API                |  | DATABASE APPLICATION |
|                    |  |                                           |  |                      |
|  +--------------+  |  |  +--------------+        +-------------+  |  |    +------------+    |
|  |              |  |  |  |              |        |             |  |  |    |            |    |
|  | PRESENTATION |  |  |  |   BUSINESS   |        | DATA ACCESS |  |  |    |            |    |
|  |    LAYER     |  |  |  |    LAYER     |        |    LAYER    |  |  |    |            |    |
|  |              | +----> |              | +----> |             | +------> |            |    |
|  |  containing  |  |  |  |  containing  |        | containing  |  |  |    |  DATABASE  |    |
|  |              |  |  |  |              |        |             |  |  |    |            |    |
|  | PRESENTATION | <----+ |   BUSINESS   | <----+ | DATA ACCESS | <------+ |            |    |
|  |    LOGIC     |  |  |  |    LOGIC     |        |    LOGIC    |  |  |    |            |    |
|  |              |  |  |  |              |        |   (+ ORM)   |  |  |    |            |    |
|  +--------------+  |  |  +--------------+        +-------------+  |  |    +------------+    |
|                    |  |                                           |  |                      |
+--------------------+  +-------------------------------------------+  +----------------------+

  RUNS ON USER'S PC              RUNS ON AN APPLICATION SERVER           RUNS ON A DATABASE
    OR WEB SERVER                                                              SERVER


In this case, each layer has its own tier, and thus, each layer runs on its own machine. 
All layers are completely uncoupled from each other, making it easier to refactor and 
expand all components of the application.

One final warning that increasing the number of layers and tiers does not come without a 
price, so you have to weigh the cost of adding a new layer or tier. Tiers in particular 
are expensive, both in terms of increasing latency and hardware costs, so think carefully
before adding one.


SOURCES

01: https://www.ethode.com/blog/fixing-spaghetti-how-to-work-with-legacy-code
02: Pattern-Oriented Software Architecture For Dummies (Robert Hanmer, 2013)
03: https://www.ou.nl/documents/40554/349790/IM0203_01.pdf
04: https://www.codeproject.com/Articles/1064240/Introduction-to-Software-Architecture
05: https://dzone.com/articles/an-introduction-to-software-architecture-what-you
06: Pattern-Oriented Software Architecture, Volume 1 - A System of Patterns 
    (F. Buschmann, H. Rohnert, P. Sommerlad, 1996)
07: https://stackoverflow.com/questions/14000762/what-does-low-in-coupling-and-high-in-cohesion-mean#
08: Architecting Modern Web Applications with ASP.NET Core and Azure v2.1.01 (Steve Smith, 2017) 
09: http://www.lhotka.net/weblog/ShouldAllAppsBeNtier.aspx
10: https://en.wikipedia.org/wiki/Abstraction_layer  
11: https://softwareengineering.stackexchange.com/questions/223947/what-is-an-abstraction-layer