AN INTRODUCTION TO PROGRAM STRUCTURES & ARCHITECTURES



    Every system has an architecture — some high-level structure that underlies the whole 
    system. Software architecture is how the pieces fit together to build the solution to 
    some business or technical need that your customer or client wants solved. The 
    architecture has a purpose.
    
    The decisions made during the creation of the architecture are truly fundamental to 
    the system because they set the stage for all the other decisions that will come 
    later.


There are two things that you will use repeatedly in a software architecture. From Robert
Hanmer's book Pattern-Oriented Software Architecture For Dummies, here are the definitions 
(from Page 25)[1]:


    1.  COMPONENTS: are the building blocks of the system — the parts of software or the 
        providers of functionality that you combine into your architecture.

    2.  SERVICES: are the things that your components provide to the actors and to one 
        another — the visible functionality of the system. As you divide the functionality 
        of the system into components, you’re also defining what services each component 
        provides. The services can be internal or external to the system.


ARCHITECTURAL STYLES

Architectural styles define the general shape of a software system. Hanmer explains the 
concept of architectural styles on Page 25:


    As I mention in Chapter 1, architectural style is like the style of a house. It may 
    define a ranch house, which sprawls horizontally in one story, or a Cape Cod house, 
    which is a two-story structure with a distinctive arrangement of doors and windows 
    on its facade.
    
    In software development, architectural style refers to the general shape of the 
    system. Choosing the appropriate style is important because all the later design 
    decisions are made in the context of this style and in concert with the style. A 
    system may have a streaming style, like Pipes and Filters (see Chapter 10), or it 
    may have an interactive style that’s shaped by Model-View-Controller (MVC; see 
    Chapter 13). The choice of appropriate style is important to your system’s success.


ARCHITECTURAL PATTERNS

Architectural patterns are specific expressions of architectural styles. On page 26, 
Hanmer provides a table that lists a few basic architectural styles and their 
corresponding patterns:


    ARCHITECTURAL STYLE         PATTERNS
    From Mud to Structure       Layers (Chapter 9), Pipes and Filters (Chapter 10),
                                Blackboard (Chapter 11)
    Distributed Systems         Broker (Chapter 12)
    Interactive Systems         Model-View-Controller (Chapter 13), Presentation-
                                Abstraction-Control (Chapter 14)
    Adaptable Systems           Microkernel (Chapter 15), Reflection (Chapter 16)


ENABLING TECHNIQUES

On page 30-31, Hanmer also discusses some enabling techniques that empower the developer to
create good software, independent of architectures and development methodologies:

    * Abstraction: Abstraction is the ability to extract the common, general parts from a 
      particular entity. You use abstraction to define a common component that will be 
      adapted to several specific situations in your system. This technique is exactly what 
      I discuss in the preceding section.

    * Encapsulation: Encapsulation is grouping related elements to preserve the boundaries
      of the abstraction. You use encapsulation to keep related functionality together 
      instead of mixing unrelated functionalities.

    * Information hiding: Information hiding keeps information that clients don’t need 
      to know hidden from them so that it’s protected and the clients don’t misuse it. 
      Encapsulation is frequently used to implement information hiding.

    * Modularization: Modularization handles system complexity by breaking the system 
      into parts with well-defined boundaries. This technique is especially useful as 
      you design software architectures because they frequently are too big to be 
      implemented efficiently as single entities. Modules can contain one or more 
      components, as I talk about elsewhere.

    * Separation of concerns: Within the system, unrelated responsibilities should be 
      separated. You use separation of concerns to define elements that perform specific 
      functions rather than elements that perform a variety of functions.

    * Coupling and cohesion: Coupling is how different modules in the system relate to 
      one another. Cohesion is a measure of how related the objects and functions within 
      a module are to each other. High cohesion and low coupling lead to systems that are 
      easy to modularize and build.

    * Sufficiency and completeness: Every component should be sufficient to include all 
      the characteristics that are needed for useful and efficient interaction with other 
      components. Every component should also capture all the important characteristics
      making it complete.

    * Separation of policy and implementation: Keeping the implementation of algorithms 
      free of system-context-related information simplifies reuse. You use this technique 
      to design parts of the system to deal with contextrelated, or policy, information 
      and other parts to implement abstract algorithms.

    * Separation of interface and implementation: This technique separates the interface 
      that clients use from the implementation of the functionality that the clients expect. 
      It makes reusing the implementation easier and promotes information hiding (discussed 
      earlier in this list).

    * Single point of reference: Avoid inconsistency by defining the items within the 
      software architecture only once. Achieving a single point of reference depends on your 
      programming environment, because some languages, like C++, make achieving this principle 
      difficult. Although C++ also requires a single point of definition, it needs 
      declarations to appear in several places.

    * Divide and conquer: Divide a problem or solution into smaller parts that are easier 
      to solve or implement. You use this technique often as you work with large problems.


On page 32, Hanmer lists a few more architectural patterns, this time in relation to 
the fundamental techniques they enable:


    ENABLING TECHNIQUE              PATTERN
    Abstraction                     Layers (Chapter 9)
    Encapsulation                   Forwarder-Receiver (Chapter 21)
    Information hiding              Reflection (Chapter 16), Whole-Part (Chapter 17)
    Modularization                  Layers (Chapter 9), Pipes and Filters (Chapter 10), 
                                    Whole-Part (Chapter 17)
    Separation of concerns          Model-View-Controller (Chapter 13)
    Coupling and cohesion           Client-Dispatcher-Server (Chapter 21),  
                                    Publisher-Subscriber (Chapter 21)
    Sufficiency and  
    completeness                    All the patterns (Chapters 9–22)
    Separation of policy and
    implementation                  Strategy*
    Separation of interface
    and implementation              Bridge*
    Single point of 
    reference                       No specific pattern
    Divide and conquer              Microkernel (Chapter 15), Whole-Part (Chapter 17)

* This pattern is available in Design Patterns: Elements of Reusable Object-Oriented 
Software, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides 
(Addison-Wesley Professional).


LAYERS, TIERS AND ABSTRACTIONS

There are some fundamental architectural principles which can be used to structure software.
Software can be separated into modules, libraries and components based on layers and tiers. 
What does that mean? 

LAYERS separate software by their function; in a software solution, a developer would find 
software elements with similar or related functions and collect them together, in a few 
files and/or folders. A collection of similar software elements that is working towards 
the same goal makes up a layer. Developers working on the project will know, for instance 
that the Controllers folder contains controllers, the Models folder models and the Views 
folder a number of views. Separating software elements with the same goal from the rest 
of the project and concentrating them into layers let's you impose logical structures 
on the project.

TIERS separate software by the hardware platforms to which they are deployed. Tiers are a 
more fundamental form of division than layers. Where layers involve collecting similar
files together, tiers usually break software up into separate programs, libraries or 
modules, depending on where that piece of software is going to run. For example, let's 
assume that you have a program with a client-server structure. The server program can run 
on server machines that you own, but if this program has a software module that must run 
on your customer's PC, then your software project needs to carve out a separate client 
program for this role. In this example then, there are two tiers, the frontend client 
running on customer computers and the servers running on your backend machines.


ABSTRACTIONS

Hanmer defines the concept of Abstraction on Page 30:


    Abstraction is the ability to extract the common, general parts from a particular 
    entity. You use abstraction to define a common component that will be adapted to several 
    specific situations in your system. This technique is exactly what I discuss in the 
    preceding section.


and then explains how tiers and layers are abstractions. Why do we need abstractions?


    What these different ways of layering the system [Tiers and Layers] have in common is 
    that they’re abstractions. An abstraction is a way of describing something in general 
    terms that leaves out the details of any specific implementation. In the examples in 
    the preceding section, the abstraction is a general layer that doesn’t describe how the 
    functionality is implemented or even precisely what it does; those details are 
    abstracted away.

    In the next section, you see that abstraction is one of the important techniques that 
    help you build better architecture. Abstractions are important to software 
    architecture because they allow you to talk about what the system does in general 
    terms before you’ve worked out all the low-level details. 

    In the same way, the three-tier architecture separates the functionality by abstractly 
    grouping the presentation server and keeping its functionality separate from the 
    functionality of the database servers. This is done because they have different 
    processing or storage needs, and the boundary of an abstraction can be drawn around 
    the layers.

    Being able to abstract the essence of a functionality and project it onto the solution 
    are important skills that you must have as a software architect.


THE MULTITIER ARCHITECTURE

For web projects that are structured in a client-server model, like this one, they are
usually organized using the MULTITIER ARCHITECTURE (AKA N-TIER ARCHITECTURE).[2] The 
multi-tier architecture separates software along two axes, namely layers and tiers, which
were discussed earlier. Recall that:

Tier: A tier physically divides software  into modules, components or libraries.
Layer: A layer separates software logically by function. 

This section will explain the layers and tiers in the traditional three-layer and 
three-tier architecture of web apps. Note that as this is the traditional structure,
it serves as a suggestive model, not a hard architecture for most apps. 


LAYERS 

Let's discuss layers in detail first.  

Client-server programs usually use multitier architecture to organize code, with the most 
common variation being a three-layer architecture. Note that a layer exists independently 
of the layers above it, but depends on the functionality provided by the layers below it. 
The three traditional layers are:


    1. Presentation Layer:   This is User Interface layer. It is the highest layer in the
                             three-layer stack. It contains all code related to the UI. 
                             This Layer will accept User commands and pass them to the 
                             layer below (the Business Logic Layer) for execution. 
                             
                             
    2. Business Logic Layer: This is the domain logic layer. This is layer that contains
                             business logic for your application. The BLL does the work of
                             processing user requests by performing operations on data 
                             stored in the Data Access Layer. The Business Logic Layer 
                             will return the results of these operations to the 
                             Presentation Layer, which will then display them to the User. 
                             Note that the Business Logic Layer sits in the middle of the 
                             layer stack, communicating to the UI layer above and the 
                             Data Access Layer below. 
                             
    3. Data Access Layer:    This layer is the bottom of the stack and it's concerned with 
                             storing and retrieving persistent data. It has the duty of 
                             managing the database of the file system. It exposes APIs to 
                             the Business Logic Layer that it can use to manipulate data: 
                             Creating, Reading, Updating and Deleting data stored on this 
                             layer. 
                             
The goal of layers is to separate the code related to the User Interface from Domain Logic 
code and the Data Access code. 


TIERS

Traditionally, there are three tiers, but the actual number of tiers should depend on your 
software project's needs. Here are the traditional tiers:  
 
 
    1. Presentation Tier:   On this tier, you would deploy the software module that 
                            presents information to and receives input from Users. This
                            module is frequently called the CLIENT or the FRONTEND.

                            The client or frontend's native hardware platform is the
                            WEB SERVER or PRESENTATION SERVER. This a server machine owned 
                            by a corporation or rented from a cloud services provider 
                            (Amazon Web Services, Google Cloud Platform, Microsoft Azure 
                            etc.). As the web is ubiquitous these days, WEB SERVERS the 
                            most common presentation tier.ASP.NET Core web apps, like HRSP, 
                            would host their frontend on a web server. 
                            
                            For web apps (websites), the web browser is typically the 
                            display medium. If a user requests your website, the client 
                            will respond by sending them the resource/website that they're
                            looking for. If the user makes changes that need to persist,
                            such as making a post on a forum or asking for an insurance 
                            quote, the browser sends this information back to the web server. 
                            However, as the web server (in a three-tier program) only 
                            handles user interface related responsibilities, the 
                            presentation layer on the web server passes on the user request 
                            to the real brain of any three-tier program, the Business Logic 
                            Tier.
                            
                            For a website, say Amazon.ca, Amazon's web servers will handle
                            requests to load Amazon.ca webpages. The browser is a standard 
                            frontend, so it's relatively easy to develop for. If we talk 
                            about the Kindle reading app instead, then the presentation tier 
                            is no longer the web server, it becomes the all the hardware 
                            platforms on which the apps runs: PCs and mobile devices; 
                            Windows, Android and iOS operating systems. Developing a 
                            frontend/GUI apps for all of these hardware platforms is a much
                            harder undertaking than developing a web frontend and server. 

                            In HRSP, the frontend role falls to Hotel-Client, which is a 
                            program that let the user communicate to HRSP application. Users 
                            will issue orders and make requests of HRSP through Hotel-Client, 
                            which will pass them on to the heart of the application, 
                            the Hotel-Server program. If HRSP were deployed in the real world, 
                            many copies of Hotel-Client would run on desktop and laptop 
                            computers that serve Hotel front desk clerks and their managers.
                            Therefore, the presentation tier for Hotel-Client is intended to
                            be PCs.
                          
    2. Business Logic Tier: On this tier, you would deploy the software module that does 
                            most of the processing. This software module, usually called the
                            APPLICATION SERVER, is the brains of every project organized into 
                            a multitier architecture: it receives User requests from the 
                            Frontend and responds by leaping into action. If the requests 
                            require creating, reading, updating or deleting data, the 
                            Application Server will issue these orders to the the Data Tier. 
                            When the Data Tier returns the results, the app server will 
                            process it and pass them on to the presentation tier, so that 
                            it can display the final results to the user.  

                            In HRSP, Hotel-Server is the Application Server. The Business 
                            Logic Tier's hardware platform is usually a physical 
                            (or virtual) SERVER. App Server programs run on these servers, 
                            listening for communications from the frontend. Client 
                            frontends pass User requests over the internet to the App 
                            Server program to do the processing.

                            
    3. Data Tier:           On this tier, you would deploy the software module that does
                            DATA ACCESS duties. Technically, in a three-tier application, 
                            the hardware for this tier would be a DATABASE SERVER, but 
                            dedicated database servers are rare except in large institutions 
                            or applications. The App Server will send orders to retrieve, 
                            update, create or change data to the Data Tier. This tier
                            comprises things like the data, databases and related features 
                            like reporting and logging. 

                            For this project, Hotel-Server also contains the Data Access 
                            Tier. 


The goal of using tiers, if it's not already clear, is to carve out code from the main
project and tailor it to run a specific hardware platform.

Layers and tiers are used to deliberately create an architecture for the project. If this 
is done correctly, changes made to a layer affect only that layer and the same applies to 
tiers. In software projects with no pre-planned architecture, there really isn't any 
structure. In such programs, what should be distinct functions, features, layers and tiers 
are jumbled into a tangled web of code. The architecture of such projects is called a 
'Big Ball of Mud', aka 'Spaghetti Code'. Changing UI code can cause unpredictable failures
in Business Logic or Data Access code. This what happens to a project that does not plan 
out its structure, architecture, architectural style, the specific architectural pattern 
and other such details during the Design phase of the project.


HOW DO LAYERS AND TIERS HELP?

The number of layers and tiers in a software project is variable and depends on the 
project's size and needs, but the number of layers and tiers usually increase with a 
program's size and complexity. 

What's the point of using layers and tiers? Rockford Lhotka explains[3]:

    Why do we layer software? Primarily to gain the benefits of logical organization and 
    grouping of like functionality. Translated to tangible outcomes, logical layers offer 
    reuse, easier maintenance and shorter development cycles. In the final analysis, proper 
    layering of software reduces the cost to develop and maintain an application. Layering 
    is almost always a wonderful thing! 

    Why do we deploy layers onto multiple tiers? Primarily to obtain a balance between 
    performance, scalability, fault tolerance and security. While there are various other 
    reasons for tiers, these four are the most common. The funny thing is that it is almost 
    impossible to get optimum levels of all four attributes – which is why it is always a 
    trade-off between them.

He continues in the article and makes a few practical comments about tiers:

    Tiers imply process and/or network boundaries. A 1-tier model has all the layers running 
    in a single memory space (process) on a single machine. A 2-tier model has some layers
    running in one memory space and other layers in a different memory space. At the very 
    least these memory spaces exist in different processes on the same computer, but more 
    often they are on different computers. Likewise, a 3-tier model has two boundaries. 
    In general terms, an n-tier model has n-1 boundaries.
    
    Crossing a boundary is expensive. It is on the order of 1000 times slower to make a 
    call across a process boundary on the same machine than to make the same call within 
    the same process. If the call is made across a network it is even slower. It is very 
    obvious then, that the more boundaries you have the slower your application will run, 
    because each boundary has a geometric impact on performance.

    Worse, boundaries add raw complexity to software design, network infrastructure, 
    manageability and overall maintainability of a system. In short, the more tiers in an 
    application, the more complexity there is to deal with – which directly increases the 
    cost to build and maintain the application.
    
    This is why, in general terms tiers should be minimized. Tiers are not a good thing, 
    they are a necessary evil required to obtain certain levels of scalability, fault 
    tolerance or security.
    
    As a good architect you should be dragged kicking and screaming into adding tiers to 
    your system. But there really are good arguments and reasons for adding tiers, and 
    it is important to accommodate them as appropriate.
    
    The reality is that almost all systems today are at least 2-tier. Unless you are using 
    an Access or dBase style database your Data layer is running on its own tier – typically 
    inside of SQL Server, Oracle or DB2. So for the remainder of my discussion I’ll primarily 
    focus on whether you should use a 2-tier or 3-tier model...

    ...the question remains whether to configure an application for 2 or 3 tiers. 
    
    Ultimately this question can only be answered by doing a cost-benefit analysis for 
    your particular environment. You need to weigh the additional complexity and cost of 
    a 3-tier deployment against the benefits it might bring in terms of scalability, fault 
    tolerance or security.


HOW LAYERS AND TIERS ARE USED IN APPLICATIONS

In a 1-tier application, all software layers run on the same machine:


+--------------------------------------------------------------------------------------------+
|                                                                                            |
|                                    THE APPLICATION                                         |
|                                                                                            |
|  +--------------------------------------------------------------------+                    |
|  |                                                                    |    +------------+  |
|  |                          APPLICATION COMPONENTS                    |    |            |  |
|  |                                                                    |    |            |  |
|  |   +--------------+       +---------------+     +---------------+   |    |            |  |
|  |   | PRESENTATION | +---> |   BUSINESS    | +-> |  DATA ACCESS  | +----> |  DATABASE  |  |
|  |   |    LOGIC     | <---+ |     LOGIC     | <-+ |     LOGIC     | <----+ |            |  |
|  |   +--------------+       +---------------+     +---------------+   |    |            |  |
|  |                                                                    |    |            |  |
|  |                                                                    |    +------------+  |
|  +--------------------------------------------------------------------+                    |
|                                                                                            |
+--------------------------------------------------------------------------------------------+


A 1-tier application is a monolith. The Presentation, Business Logic and Data Access 
Layers live in the same tier. This makes the layers in this application tightly connected. 
All three layers are packaged in a single executable and run on the same machine. 

In such a tightly integrated application, changing one layer will probably require changes 
to the other layers. As the program is designed for a single machine, scaling the number of
processors is probably not possible. For the same reason, the portability factor of this 
design is low. Nevertheless, it may make sense to use this design for small applications
that don't handle much traffic or need much resources.

In a a 2-tier application, the program is usually separated into two halves:
a client and a server. These programs run on two separate machines:


+------------------------------------------------+ +-----------------------------------------+
|                CLIENT APPLICATION              | |          SERVER-SIDE APPLICATION        |
|                                                | |                                         |
| +--------------------------------------------+ | | +---------------------+                 |
| |                   LAYER 1                  | | | |  DATA ACCESS LAYER  |  +------------+ |
| |                                            | | | |                     |  |            | |
| | +----------------+      +----------------+ | | | |  +---------------+  |  |            | |
| | |  PRESENTATION  | +--> |    BUSINESS    | +------> |  DATA ACCESS  | +-> |  DATABASE  | |
| | |     LOGIC      | <--+ |     LOGIC      | <------+ |     LOGIC     | <-+ |            | |
| | +----------------+      +----------------+ | | | |  +---------------+  |  |            | |
| |                                            | | | |                     |  +------------+ |
| +--------------------------------------------+ | | +---------------------+                 |
+------------------------------------------------+ +-----------------------------------------+

        RUNS ON USER'S PC OR 


In this variation of the 2-tier application, the Presentation and Business Logic layers are
combined into the client. The client would probably run on a user's machine while the Data 
Access Layer and the Database live on a server. Another variation of this application would 
bundle the Business Logic and Data Access Layer together. 

This application is less tightly coupled than the 1-tier application, so making changes like
swapping out the database become easier. The Presentation and Business Logic layers are still
coupled, making it likely that any changes to one layer could affect the other. 

In a 3-tier application, you would have, three programs running on three different machines: 
a client application running on the user's PC or perhaps on a web server, an App server 
program (containing the Business Logic Layer) running on an Application Server the Database
backend will run on a Database Server:


+--------------------+  +-------------------------------------------+  +----------------------+
| CLIENT APPLICATION |  |             APP SERVER/API                |  |    DATABASE SERVER   |
|                    |  |                                           |  |                      |
|  +--------------+  |  |  +--------------+        +-------------+  |  |    +------------+    |
|  |              |  |  |  |              |        |             |  |  |    |            |    |
|  | PRESENTATION |  |  |  |   BUSINESS   |        | DATA ACCESS |  |  |    |            |    |
|  |    LAYER     |  |  |  |    LAYER     |        |    LAYER    |  |  |    |            |    |
|  |              | +----> |              | +----> |             | +------> |            |    |
|  |  containing  |  |  |  |  containing  |        | containing  |  |  |    |  DATABASE  |    |
|  |              |  |  |  |              |        |             |  |  |    |            |    |
|  | PRESENTATION | <----+ |   BUSINESS   | <----+ | DATA ACCESS | <------+ |            |    |
|  |    LOGIC     |  |  |  |    LOGIC     |        |    LOGIC    |  |  |    |            |    |
|  |              |  |  |  |              |        |             |  |  |    |            |    |
|  +--------------+  |  |  +--------------+        +-------------+  |  |    +------------+    |
|                    |  |                                           |  |                      |
+--------------------+  +-------------------------------------------+  +----------------------+

  RUNS ON USER'S PC              RUNS ON AN APPLICATION SERVER           RUNS ON A DATABASE
    OR WEB SERVER                                                              SERVER


In this case, each layer has its own tier, and thus, each layer runs on its own machine. All
layers are completely uncoupled from each other, making it easier to refactor and expand all
elements of the application.


THE APPLICATION OF SOFTWARE ARCHITECTURE AND PATTERNS

THE CLIENT-SERVER MODEL

This program is a web app, which means that it communicates over the internet. This requires
this program to be divided into two or more parts. Note that projects rarely completely 
conform to architectures like N-Tier or patterns like MVC. Reality rarely deigns to be that
cooperative, so you'll have to adapt architectures and patterns to fit your problem. 

This project is not an exception; it uses the concept of tiers from the Multi-tier 
architecture and its layers are modeled after MVC.

This project needs a client and an application server, so it is structured in an application 
structure called the CLIENT-SERVER MODEL[3]. The wikipedia article on this architecture 
provides this explanation:


    The client–server model is a distributed application structure that partitions tasks or 
    workloads between the providers of a resource or service, called servers, and service 
    requesters, called clients. Often clients and servers communicate over a computer network 
    on separate hardware, but both client and server may reside in the same system. A server 
    host runs one or more server programs which share their resources with clients. A client 
    does not share any of its resources, but requests a server's content or service function. 
    Clients therefore initiate communication sessions with servers which await incoming 
    requests. Examples of computer applications that use the client–server model are Email, 
    network printing, and the World Wide Web.
    
    
This project, Hotel Reservation System Project (HRSP), is divided into 3 separate projects:


    1. Hotel-Client,            (Client Frontend)
    2. Hotel-Server, and        (Application Server)
    3. Common                   (Shared Library)


Hotel-Client is the client program, Hotel-Server is the Application Server and Common is a 
library that stores files shared by these two programs. A copy of Common will be shipped 
with all copies of Hotel-Client and Hotel-Server.


AN ARCHITECTURAL PATTERN: MODEL-VIEW-CONTROLLER (MVC)

Model-View-Controller (MVC) is an architectural pattern that is widely used in web
programming. This project uses ASP.NET Core for building web pages; ASP.NET Core makes use 
of MVC for structuring web applications. Given the pervasiveness of MVC, you should know 
something about this pattern. 

Pablo Pastor introduces MVC, its history and its purpose in a blog post[4]:


    MVC is not a design pattern, it is an Architectural pattern that describes a way to 
    structure our application and the responsibilities and interactions for each part 
    in that structure.

    It was first described in 1979 and, obviously, the context was a little bit different. 
    The concept of web application did not exist. Tim Berners Lee sowed the seeds of World 
    Wide Web in the early nineties and changed the world forever. The pattern we use today 
    for web development is an adaptation of the original pattern.

    The wild popularization of this structure for web applications is due to its inclusion 
    in two development frameworks that have become immensely popular: Struts and Ruby on 
    Rails. These two environments marked the way for the hundreds of frameworks created 
    later.


If you check the 'Architectural Patterns' section of this file, you'll note that MVC is an
architectural pattern that falls under the architectural style of Interactive Systems. 
Interactive Systems are computer systems (a bundle of hardware and software) that has lots
of interaction between humans and the computer system. Desktop and laptop PCs and mobile 
devices are good examples of interactive systems. Embedded devices, for instance in your 
car's engine or in a factory's conveyor belt are examples of systems with relatively 
little human-computer interaction. Interactive applications are things like games, word 
processors, CLI apps; all of them take substantial user input as part of their normal 
functioning.

Interactive systems and applications are designed to respond to human requests. This is 
where MVC comes in: It appears to be an architectural pattern that best suited to 
organizing the layers in an interactive application. All interactive applications are 
similar, but not identical to one another. 


THE COMPONENTS OF MODEL-VIEW-CONTROLLER 

MVC's goal is to separate the following responsibilities in an application into three 
distinct layers:

    1. Model
    2. View
    3. Controller

In the multi-tier architecture, communication goes linearly through layers/tiers: the 
client tier must cannot directly communicate with the Data Access tier, it has to pass 
messages through the Business logic tier. However, in MVC, the layers interact in a 
triangular structure. Below, see the diagram that explains this pattern. To fully 
understand it, read the explanations below the diagram. To decipher the diagram, start 
with the User. 


                                     +-------------------------------------------------------------------------+
                                     |                                                                         |
                                     |                                                                         |
                                     |                                                                         |
                                     |                              AN MVC PROGRAM                             |
                                     |                                                                         |
                       [REQUESTS]    |                                                                         |
                    The User issues  |                                                                         |
                    orders to the    |                                                                         |
                    program through  |                       The View sends user input                         |
                    the UI (View)    |                           to the Controller                             |
+-----------------+                  |  +-----------------+                              +-----------------+   |
|                 | +-----------------> |                 | +--------------------------> |                 |   |
| THE CLIENT/USER |                  |  |       VIEW      |                              |    CONTROLLER   |   |
|                 | <-----------------+ |                 | <--------------------------+ |                 |   |
+-----------------+                  |  +-----------------+                              +-----------------+   |
                    Information is   |                       The Controller sometimes                          |
                    presented to     |     ^                 updates the View directly                  +      |
                    the User via     |     |                                                            |      |
                    the User         |     |                                             [MANIPULATES   |      |
                    Interface (View) |     |                                              MODELS]       |      |
                      [RESPONSES]    |     | [UPDATES VIEW]                              The Controller |      |
                                     |     | When the                                    responds to    |      |
                                     |     | Models in the +---------------------------+ the user       |      |
                                     |     | Database      |                           | request by     |      |
                                     |     | change, the   |     DATA ACCESS LAYER     | operating on   |      |
                                     |     | View gets     |                           | Model objects  |      |
                                     |     | updated       |     +---------------+     | in the Database|      |
                                     |     +-------------+ |     | MODEL OBJECTS |     | <--------------+      |
                                     |                     |     |    (IN THE    |     |                       |
                                     |                     |     |   DATABASE)   |     |                       |
                                     |                     |     +---------------+     |                       |
                                     |                     +---------------------------+                       |
                                     |                                                                         |
                                     +-------------------------------------------------------------------------+


I'm going to explain these layers plus a fourth layer, ViewModel, that is often used in
ASP.NET Core projects. Note that the explanation below is tailored to ASP.NET Core; other
MVC frameworks may be different.


1. Model: The model layer is probably the simplest layer in MVC. When it comes to models,
   there is distinction to be made between Model classes and model objects. The former 
   are templates for the latter. Model classes live in the Models folder whereas Model 
   objects live in the Data Access layer of a project.

   Model classes are classes that define important business entities for your application. 
   A model class represents the knowledge that the application needs to know about a 
   certain business entity. Therefore, a Model class needs to be designed to capture 
   information important to to each entity. At this stage, it's important to be selective 
   about the information you capture.
   
   In a Calendar program, things like the Day, Alarms, Contacts etc. would be the Business 
   entities. To a Day class, things like Date, Day of the Week, Scheduled events etc., 
   would qualify as important information. So, these things will be represented as class 
   properties. What kind of information should be left out? Here's a rather extreme 
   example: you probably won't need a property that captures how many days have passed 
   since the death of Julius Caesar. It would not make much sense in a Calendar app; your 
   users probably don't care about this piece of information.
   
   In a model class, you can choose to add Data Annotations to each property to place 
   limitations on the values accepted by a property. For example, you can use C#'s 
   [PhoneNumber] annotation to ensure that all values for the PhoneNumber property follow 
   the standard. All objects instantiated from this class have restrictions on the value 
   for the phone number: it is limited a certain length, and allows only integers, brackets 
   and dashes.
   
   Model classes do very little besides serve as a template for business entities. When
   the business logic layer of an MVC application, the Controller layer, is instructed by
   a user or its internal logic to create business entities, it will use the pre-defined 
   Model classes as templates for these objects. The Controller typically stores these 
   newly created objects in a database. Model objects will live there, and when needed, 
   the Controller layer will consult or modify them.
   
   The Common library contains the Models layer for HRSP.
   

2. View: "A view is a (visual) representation of its model. It would ordinarily highlight
   certain attributes of the model and suppress others. It is thus acting as a presentation
   filter."[5] 
   
   The View layer is the presentation layer i.e. it controls how data from model objects are
   formatted and presented to the user. The View provides a variety of ways to present data 
   it receives from Model objects. The user can direct the View to display information about 
   model(s).  With this information, the user use the UI (the View) to issue orders to the 
   program. The View can be an HTML webpage, a GUI, a text-based UI, Razor Views etc.

   HRSP does not use standard ASP.NET Core Views due to the fact that it uses the Console
   to display text-based information to the user instead of HTML-based web pages. 
   Hotel-Client contains the View layer of this application.


3. ViewModel: This layer, strictly speaking, is not a part of MVC. It belongs to a variant 
   of MVC, the Model-View-ViewModel (MVVM) pattern. However, as MVC/MVVM is not an 
   either/or choice[6], I'm introducing this concept here. In MVVM, ViewModels take up the 
   role of Controllers, but do not necessarily replace them completely. See the sixth 
   source for more details. Here is an explanation of what ViewModels do from an MSDN 
   article[7]:
   

       The ViewModel class, which is the bridge between the view and the model. Each View
       class has a corresponding ViewModel class. The ViewModel retrieves data from the 
       Model and manipulates it into the format required by the View. It notifies the View 
       if the underlying data in the model is changed, and it updates the data in the Model 
       in response to UI events from the View.

       
   However, in ASP.NET Core, viewmodels appear to be passive containers. There are two 
   ways to send information to the user in an ASP.NET Core MVC application: have the 
   Controller send Models directly to the View, which displays it to the user OR the have 
   Controller load into the Viewmodel only the parts of the Model that the View requires, 
   and then send that to the View. 
   
   Though the first method is easier, in ASP.NET Core MVC, it is a best practice to use 
   viewmodels as intermediaries between models and views. There are two reasons for this: 
   The View() method can usually accept only a single model or Viewmodel object and 
   secondly, Viewmodels let you tailor models so that only required model data gets sent 
   to the View. For these reasons, only necessary Models are packed as properties into a
   Viewmodel, which is then sent to the View(). You should use a Viewmodel even if you 
   need to send only a single model to the View(), as this is something that could change 
   in the future. For more information, see the project 'ASPNETCore WebApp 1A - Routing'.

   HRSP does not use any Viewmodels.


4. Controller: The controller layer is the brain of the application. It consists of 
   controller class(es) whose methods respond to incoming requests. Business rules and 
   the business logic of the application are defined and applied in controller class 
   methods. 
   
   When a user makes a request via the View, it gets passed to a controller whose 
   method is designated to respond to that particular request. Controllers will process, 
   interpret and validate incoming requests. Once that is done, it is their job to query 
   and modify model objects in the database and create or update Views to fulfill the 
   user request. By doing these things, this layer controls and directs application flow.  


PROS AND CONS OF THE MVC PATTERN

This list is taken from Pg 194-195 of 'Pattern-Oriented Software Architecture For 
Dummies'[1]:


    Benefits

    The flexibility of decoupling the data (model) from the output (view) and input 
    (controller) is the primary benefit of the MVC architecture. You’ll see this over 
    and over again in the following list of benefits:

    ✓ The model is strictly separated from the UI components in this architecture. You 
      can use the same data to supply multiple views.

    ✓ Changes to the data in the underlying model are reflected in all the views 
      automatically. This is possible because there is a single source of the data being 
      displayed.

    ✓ You can change the view and controller elements of the system without changing the 
      data model. This capability increases the flexibility of the system. You can keep the 
      underlying model element consistent and intact, and exchange the view and controller 
      components of the system.

    ✓ Because the UI code is independent of the model, when you need to make major changes 
      in the UI section, the underlying data doesn’t need to change. This kind of major 
      change can result from moving the system to new hardware or to hardware that has a 
      different look and feel.

    ✓ The views don’t interact. As a result, you can change an individual view without 
      having to make changes in the other views.

    ✓ MVC architectures can be used as frameworks to be used and extended in other 
      situations. The three components are related yet independent, which simplifies 
      maintenance and evolution.

    Liabilities

    In addition to the benefits, liabilities come along with using MVC. You must balance 
    these liabilities with the benefits when you design your system:

    ✓ Complexity is increased by separating the three components of MVC. You have more 
      components to build and maintain than you would if you’d designed the system as a 
      monolith. Unless you need flexibility in the UI or the views, MVC may add more 
      overhead than your application really needs.

    ✓ Changes to the model are published to all the views that subscribed for them. The 
      number of recipients of change-notification messages increases as the system gets 
      bigger. To overcome this liability, consider the big picture when you design the 
      scope of changes that result in update publications...

    ✓ The controller and the views grow closer with time. Even though the components are 
      individuals, they have strong relationships that limit your ability to reuse one 
      component without the others. As the system grows and evolves, views will be added 
      to the system, along with resulting enhancements to the controller that allow the 
      views to be selected and controlled. Because the components are so intertwined, 
      reusing only the controller or only the views is more difficult than reusing the
      controller and views together. The relationship also limits your ability to insert
      new versions of either component, because the new version must be adapted to support 
      the component that isn’t being replaced.

    ✓ The controller and view components know quite a lot about the model. Changes in the
      model may require changes in both of the other two components. Adding indirection 
      helps mitigate this liability, however, as I discuss in the implementation section 
      (“Step 4: Design and build the controllers”) later in this chapter.

    ✓ Inefficient data access can result because of the separation of views and model data 
      and the need to go through the model’s API. This problem is especially apparent if the 
      view must request unchanged data from the model frequently. You can improve 
      responsiveness, however, by designing the view to cache data.

    ✓ Both controller and view components require changes when they’re ported to a new 
      system. These components contain some platformdependent code, so when the components 
      are ported to a new system, the platform-dependent code requires changes.


ARCHITECTURE OF THE HOTEL-SERVER PROJECT


                         FRONTEND                                 BACKEND
                    +----------------+                      +----------------+
                    |                | <------------------+ |                |
                    |  HOTEL-CLIENT  |                      |  HOTEL-SERVER  |
                    |                | +------------------> |                |
                    +----------------+                      +----------------+
                    
                            +                                       +
                            |                                       |
                            |              SHARED FILES             |
                            |          +------------------+         |
                            |          |                  |         |
                            +--------> |      COMMON      | <-------+
                                       |                  |
                                       +------------------+