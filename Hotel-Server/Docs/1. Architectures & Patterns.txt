1. INTRODUCTORY REMARKS

Web projects like the Hotel-Reservation-System Project (HRSP) are structured into 
sub-components by implementing certain architectures and architectural patterns. 
Dividing code into clearly demarcated modules has been found to make programs simpler
to develop, maintain and extend, and easier to debug. This article will discuss 
architectural concepts required to develop web applications.

First, basic architectural concepts will be discussed:


    1. Introduction to Structures and Architectures
    2. Architectural Styles
    3. Architectural Patterns
    4. Enabling Techniques
    5. Layers and Tiers


Then the arcticle will move on to examining architectures best-suited to web applications:


    1. Distributed Computing and an Introduction to DC Architectures
    2. A 2-Tier Distributed Architecture: The Client-Server Model
    3. A 3+ Tier Distributed Architecture: Multitier/N-Tier
    4. An Architectural Pattern for Interactive Systems: Model-View-Controller (MVC)


Finally, after discussing distributed computing architectures and the MVC pattern, I will
analyze and discuss the structure and architecture, and architectural patterns used in 
Hotel-Reservation-System.


2.1 AN INTRODUCTION TO PROGRAM STRUCTURES & ARCHITECTURES

From Robert Hanmer's book Pattern-Oriented Software Architecture For Dummies, here's a 
definition of Software Architecture, Page 9[1]:


    Every system has an architecture — some high-level structure that underlies the whole 
    system. Software architecture is how the pieces fit together to build the solution to 
    some business or technical need that your customer or client wants solved. The 
    architecture has a purpose.
    
    The decisions made during the creation of the architecture are truly fundamental to 
    the system because they set the stage for all the other decisions that will come 
    later.


When a programmer designs a software solution's architecture, she is dividing it into
services and components. Hanmer defines them on Page 25[1]:


    1.  COMPONENTS: are the building blocks of the system — the parts of software or the 
        providers of functionality that you combine into your architecture.

    2.  SERVICES: are the things that your components provide to the actors and to one 
        another — the visible functionality of the system. As you divide the functionality 
        of the system into components, you’re also defining what services each component 
        provides. The services can be internal or external to the system.


When designing an application's architecture, Hanmer suggests considering these factors; 
Pg 10[1]:

    ✓ Goals and philosophy of the system: The architecture explains the goals and 
      describes the purpose of the system, as well as who uses it and what problem it 
      solves.

    ✓ Architectural assumptions and dependencies: The architecture explains the 
      assumption made about the environment and about the system itself. The architecture 
      also explains any dependencies on other systems or on the builders of the system.

    ✓ Architecturally significant requirements: The architecture points to the most 
      significant requirements that shaped it.

    ✓ Packaging instructions for subsystems and components: The architecture explains how 
      the parts of the system are deployed on computing platforms and how the parts must 
      be combined for proper functioning. The subsystems and components are the building 
      blocks of the architecture.

    ✓ Critical subsystems and layers: The architecture explains the different views and 
      parts of the system and how they relate. It also explains the most critical 
      subsystems in detail.

    ✓ References to architecturally significant design elements: The architecture 
      describes the most prominent and significant parts of the design. 
      
    ✓ Critical system interfaces: The architecture describes the interfaces of the system, 
      with special attention to the interfaces that are critical to meet the system’s 
      requirements.

    ✓ Key scenarios that describe critical behavior of the system: The architecture
      explains the most important scenarios that illustrate and explain how the system 
      will be used.


2.2 ARCHITECTURAL STYLES

Architectural styles define the general shape of a software system. Hanmer explains the 
concept of architectural styles on Page 25[1]:


    As I mention in Chapter 1, architectural style is like the style of a house. It may 
    define a ranch house, which sprawls horizontally in one story, or a Cape Cod house, 
    which is a two-story structure with a distinctive arrangement of doors and windows 
    on its facade.
    
    In software development, architectural style refers to the general shape of the 
    system. Choosing the appropriate style is important because all the later design 
    decisions are made in the context of this style and in concert with the style. A 
    system may have a streaming style, like Pipes and Filters (see Chapter 10), or it 
    may have an interactive style that’s shaped by Model-View-Controller (MVC; see 
    Chapter 13). The choice of appropriate style is important to your system’s success.


The architectural style of a program determines the choice of the main architectural 
pattern. The next section will introduce the idea of Architectural Styles and their
corresponding Architectural Patterns.


2.3 ARCHITECTURAL PATTERNS

Architectural patterns are specific expressions of architectural styles. On page 26, 
Hanmer provides a table that lists a few basic architectural styles and their 
corresponding patterns[1]:


    ARCHITECTURAL STYLE         PATTERNS
    From Mud to Structure       Layers (Chapter 9), Pipes and Filters (Chapter 10),
                                Blackboard (Chapter 11)
    Distributed Systems         Broker (Chapter 12)
    Interactive Systems         Model-View-Controller (Chapter 13), Presentation-
                                Abstraction-Control (Chapter 14)
    Adaptable Systems           Microkernel (Chapter 15), Reflection (Chapter 16)


At this point, just note that HRSP uses two architectural styles and their corresponding
patterns:


    Distributed Systems: Client-Server Model
    Interactive Systems: Model-View-Controller


Yes, a project can combine two architectural styles/patterns. These two styles and 
patterns are very common in web world, which is why the rest of the article will explore
these topics in some detail. 


2.4 ENABLING TECHNIQUES

On page 30-31, Hanmer also discusses some enabling techniques that empower the developer to
create good software, independent of architectures and development methodologies[1]:


    ✓ Abstraction: Abstraction is the ability to extract the common, general parts from a 
      particular entity. You use abstraction to define a common component that will be 
      adapted to several specific situations in your system. This technique is exactly what 
      I discuss in the preceding section.

    ✓ Encapsulation: Encapsulation is grouping related elements to preserve the boundaries
      of the abstraction. You use encapsulation to keep related functionality together 
      instead of mixing unrelated functionalities.

    ✓ Information hiding: Information hiding keeps information that clients don’t need 
      to know hidden from them so that it’s protected and the clients don’t misuse it. 
      Encapsulation is frequently used to implement information hiding.

    ✓ Modularization: Modularization handles system complexity by breaking the system 
      into parts with well-defined boundaries. This technique is especially useful as 
      you design software architectures because they frequently are too big to be 
      implemented efficiently as single entities. Modules can contain one or more 
      components, as I talk about elsewhere.

    ✓ Separation of concerns: Within the system, unrelated responsibilities should be 
      separated. You use separation of concerns to define elements that perform specific 
      functions rather than elements that perform a variety of functions.

    ✓ Coupling and cohesion: Coupling is how different modules in the system relate to 
      one another. Cohesion is a measure of how related the objects and functions within 
      a module are to each other. High cohesion and low coupling lead to systems that are 
      easy to modularize and build.

    ✓ Sufficiency and completeness: Every component should be sufficient to include all 
      the characteristics that are needed for useful and efficient interaction with other 
      components. Every component should also capture all the important characteristics
      making it complete.

    ✓ Separation of policy and implementation: Keeping the implementation of algorithms 
      free of system-context-related information simplifies reuse. You use this technique 
      to design parts of the system to deal with contextrelated, or policy, information 
      and other parts to implement abstract algorithms.

    ✓ Separation of interface and implementation: This technique separates the interface 
      that clients use from the implementation of the functionality that the clients expect. 
      It makes reusing the implementation easier and promotes information hiding (discussed 
      earlier in this list).

    ✓ Single point of reference: Avoid inconsistency by defining the items within the 
      software architecture only once. Achieving a single point of reference depends on your 
      programming environment, because some languages, like C++, make achieving this principle 
      difficult. Although C++ also requires a single point of definition, it needs 
      declarations to appear in several places.

    ✓ Divide and conquer: Divide a problem or solution into smaller parts that are easier 
      to solve or implement. You use this technique often as you work with large problems.


The architectural patterns you choose are determined by the enabling technique you want 
to optimize for in your program design. On page 32, Hanmer lists a few more architectural 
patterns, this time in relation to the fundamental techniques they enable[1]:


    ENABLING TECHNIQUE              PATTERN
    Abstraction                     Layers (Chapter 9)
    Encapsulation                   Forwarder-Receiver (Chapter 21)
    Information hiding              Reflection (Chapter 16), Whole-Part (Chapter 17)
    Modularization                  Layers (Chapter 9), Pipes and Filters (Chapter 10), 
                                    Whole-Part (Chapter 17)
    Separation of concerns          Model-View-Controller (Chapter 13)
    Coupling and cohesion           Client-Dispatcher-Server (Chapter 21),  
                                    Publisher-Subscriber (Chapter 21)
    Sufficiency and  
    completeness                    All the patterns (Chapters 9–22)
    Separation of policy and
    implementation                  Strategy*
    Separation of interface
    and implementation              Bridge*
    Single point of 
    reference                       No specific pattern
    Divide and conquer              Microkernel (Chapter 15), Whole-Part (Chapter 17)

* This pattern is available in Design Patterns: Elements of Reusable Object-Oriented 
Software, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides 
(Addison-Wesley Professional).


2.5 LAYERS AND TIERS

There are some fundamental architectural principles which can be used to structure 
software. Instead of developing monolithic applications that are a huge tangled bundle of 
interconnected components, software can be separated into modules, libraries and other
components by using the architectural principles of layers and tiers. 

How do they work?

LAYERS separate software by their function. In a software solution, a developer would find 
software elements with similar or related functions and collect them together, in a few 
files and/or folders. When a collection of similar software elements that are working 
towards the same goal are separated from the main program into dedicated folders and/or 
files, it is called a layer. 

If a project implements the MVC architectural pattern, its functions are separated into
three layers: Models, Views and Controllers. Developers working on an MVC project will 
know that the Controllers folder will contain only controller files, the Models folder 
model class files and the Views folder will hold HTML, CSS and Javascript files. 

Each layer has its own set of responsibilities: The Model layer contains classes that 
define the program's data elements, Views are responsible for displaying information to 
the user and the Controller layer responds to user requests by issuing orders to the other
two layers. Separating software elements with the same goal from the rest of the project 
and concentrating them into layers let's you separate concerns to prevent unneccessary 
entanglements between elements of differing functions and imposes a logical structure on
the project.

TIERS separate software by the hardware platforms to which a software component is to be
deployed. Tiers are a more fundamental form of division than layers. Where layers involve
collecting files with similar functions together into folders, tiers usually break 
software up into separate programs, modules or libraries, depending on where that piece 
of software is going to run. 

For example, let's assume that you have a web application, which has a client-server 
architecture (More on this later.). Such an application is divided itself into two 
parts, the Client and the Server. In this example, there are two tiers, the client, 
which runs on a customer's computer and the Server, which runs on a server machine.


3.1 DISTRIBUTED COMPUTING

HRSP is a web application, which means that it works over the internet. This brings up 
the concept of Distributed Computing. Here is a definition for it[2]:


    Distributed computing is a field of computer science that studies distributed systems. 
    A distributed system is a system whose components are located on different networked 
    computers, which then communicate and coordinate their actions by passing messages to 
    each other. The components interact with each other in order to achieve a common 
    goal... Examples of distributed systems... [include] ...massively multiplayer online 
    games to peer-to-peer applications. 

    A computer program that runs within a distributed system is called a distributed 
    program (and distributed programming is the process of writing such programs). There 
    are many different types of implementations for the message passing mechanism, 
    including pure HTTP, RPC-like connectors and message queues.


When one has to design software that works over any network, such as the internet, it 
usually cannot be designed as a single monolithic application. Why? Because in such 
programs, work is not being done by single monolithic program that runs on a single 
computer. Rather, web applications are often comprised of two, three or more 
sub-components (layers and tiers), and some of these are standalone programs designed to 
run on separate machines. This should bring to mind the concept of tiers. That's right, 
web applications are typically designed with multiple-tier architectures. Clients, 
App Servers and Database Servers can all be part of the same application, but run on 
different machines if needed.

The sub-programs are usually installed on separate machines (tiers) and communicate over
the network (the internet, institutional intranets etc.) to coordinate towards 
accomplishing the application's purpose. Others will be layers that live within a tier.

As a web application tends to have multiple layers and tiers that are spread out over 
multiple machines, its resources and duties are distributed over multiple devices. Hence,
the name distributed computing. Therefore, when a programmer designs a web application, 
she has to design the application with a distributed architecture. That is to say, a 
program that is broken up into multiple layers and sub-programs.

At this point, let's talk about functional layers. Most web applications recognize that 
they have at least three major groupings of functions (layers):


    * User Interface
    * Application Processing
    * Data Management


When choosing a distributed architecture for your program, you will have to choose how 
to collect or separate these functions into layers and tiers. There are several ways of 
dividing up a distributed application. The wikipedia article on this topic provides a brief 
explanation for a number of basic architectures[2]. The list of distributed architectures
below distinguishes between them on the basis of the number of tiers they have:


    * CLIENT-SERVER: architectures where smart clients contact the server for data then 
      format and display it to the users. Input at the client is committed back to the 
      server when it represents a permanent change. [2-tier architecture]

    * THREE-TIER: architectures that move the client intelligence to a middle tier so 
      that stateless clients can be used. This simplifies application deployment. Most 
      web applications are three-tier. [3-tier architecture]

    * N-TIER: architectures that refer typically to web applications which further forward 
      their requests to other enterprise services. This type of application is the one 
      most responsible for the success of application servers. [3+ tier architecture]

    * PEER-TO-PEER: architectures where there are no special machines that provide a 
      service or manage the network resources. Instead all responsibilities are uniformly
      divided among all machines, known as peers. Peers can serve both as clients and as
      servers. [This architecture is different from the other three. It can potentially
      have millions of peers.]


Client-Server is a 2-tier architecture, where the application is split into two parts, 
Client and Server. Multitier/N-Tier is a distributed architecture that is divided into 
3 or more parts. Three-tier architecture is considered a variant of Multitier 
architecture. They usually have these three tiers: UI Server, App Server and Database
Server.

P2P architectures are unlike the other three architectures. In the other three traditional
architectures, the consumption of resources and supply of duties is divided by tier. This
means that every part of an N-tier application, regardless of whether it has 2, 3 or more
tiers, has a special duty, a role that only it can perform for the application. In a 
client-server architecture, the client acts as a conduit, displaying information and 
taking requests from the user. The server's duty is do the processing and data management. 

A P2P application is different; it is a monolithic program that contains all or most 
modules of the application. Therefore, P2P peers are said to be equally privileged 
because every peer has the same capabilities and responsibilities. A peer can act as 
both client and server and does processing on the local machine. The results of its work 
can be shared across a network to peers running on other machines. 


3.1.1 CLIENT-SERVER MODEL (2-TIER ARCHITECTURE)

The wikipedia article for the CLIENT-SERVER MODEL architecture[3] provides this 
explanation:


    The client–server model is a distributed application structure that partitions tasks 
    or workloads between the providers of a resource or service, called servers, and 
    service requesters, called clients. Often clients and servers communicate over a 
    computer network on separate hardware, but both client and server may reside in the
    same system. A server host runs one or more server programs which share their 
    resources with clients. A client does not share any of its resources, but requests 
    a server's content or service function. Clients therefore initiate communication 
    sessions with servers which await incoming requests. Examples of computer 
    applications that use the client–server model are Email, network printing, and the 
    World Wide Web.


Programs with a client-server architecture have two parts:

    * CLIENT: The client is the frontend; it's the user interface through which the user
      interacts with the application. When the user wants a resource or wants the program
      to do something, she will pass these instructions to the client. The client will 
      send these requests to the server. 

    * SERVER: The server will respond to client requests by sending back resources or 
      doing the operation that the user asked for. The server in this model handles two
      functions, application processing and data management.


HRSP needs two tiers, a client and an application server, so it is structured in a 
client-server architecture. 
    
    
3.1.2 THE MULTITIER/N-TIER ARCHITECTURE (3+ TIER ARCHITECTURE)

Programs with three or more tiers usually use the multitier architecture to organize 
code. The multi-tier architecture separates software along two axes, namely layers 
and tiers. Recall that:

Tier: A tier physically divides software into modules, components or libraries.
Layer: A layer logically organizes software elements by function. 

This section will explain the layers and tiers in the traditional three-layer and 
three-tier architecture of web applications. In this architecture, the layers are tiers, 
i.e. each layer in the application is a separate tier. As this is a traditional 
structure, it only serves as a guideline. Reality rarely deigns to completely conform to 
architectural theories, so you'll have to adapt architectures and patterns when designing 
your software solution.


LAYERS 

Let's discuss layers in detail first.  

Note that a layer exists independently of the layers above it, but depends on the 
functionality provided by the layers below it. The three traditional layers are:


    1. PRESENTATION LAYER
    This is the User Interface layer. It is the highest layer in the three-layer stack. 
    It contains all code related to the UI. This layer is charge of displaying program 
    data to the user and in turn, accepting their commands and passing them to the layer
    below (the Business Logic Layer) for execution. 
                             
                             
    2. BUSINESS LOGIC LAYER
    This is the domain logic layer; it contains business logic for your application. 
    The BLL does the work of processing user requests by performing operations on data 
    stored in the Data Access Layer. The Business Logic Layer will return the results of 
    these operations to the Presentation Layer, which will then display them to the user. 
    Note that the Business Logic Layer sits in the middle of the layer stack, communicating 
    to the UI layer above and the Data Access Layer below. 
                             
    3. DATA ACCESS LAYER
    This layer is the bottom of the stack and its job is to interface with a data source,
    such as a database or file system, to store, modify or retrieve persistent data.
    Upon request by the other two layers, it is DAL's job to convert data from a row of 
    fields in a database table into objects for their consumption. The DAL exposes APIs 
    to the Business Logic Layer that it can use to manipulate stored data, letting the 
    BLL Create, Read, Update and Delete data stored on this layer. 

                             
The goal of layers is to separate functionalities from each other. Presentation logic
should not entangled with Business logic or Data Management logic. 


TIERS

Traditionally, there are three tiers, but once again, the actual number of tiers in your
project should depend on its scope and needs. Here are the traditional tiers:  
 
 
    1. PRESENTATION TIER
    On this tier, you would deploy the sub-program that presents information to and 
    receives input from Users. This module is frequently called the CLIENT or the 
    FRONT-END. It contains the presentation layer of the project; it is concerned with
    presenting information to the user and accepting directions from them via some type 
    of user interface (E.g. Graphical User Interface (GUI), Text-based User Interface 
    (TUI) etc.) 

    The client or frontend's native hardware platform (tier) is the PRESENTATION SERVER. 
    This is a server machine typically owned by the business or rented from a cloud 
    services provider (Amazon Web Services, Google Cloud Platform, Microsoft Azure etc.). 
    As the web is ubiquitous these days, WEB SERVERS are the most common presentation 
    tier. ASP.NET Core web apps would probably host their frontend on a web server. 
                            
    For web applications (websites), the web browser is typically the delivery mechanism. 
    If a user opens a browser and requests your website, that request will be forwarded 
    to your presentation server (a web server). The web server will pass on the request 
    to next tier, the App Server, which will return requested website data to the web 
    server. The web server will convert this data into a graphical interface and send it 
    back to the browser where it will be displayed to the user.

    The browser is a standards-based way to deliver web content, making it (relatively) 
    easy to develop for. The Amazon.com website's presentation tier are the web servers 
    that tasked with deliving this website to browsers. However, the web is only one of 
    many possible ways to display information to the user. Other presentation tiers 
    exist; if we talk about the Amazon Kindle reading app instead, then the presentation 
    tier is no longer the web server, it becomes the all the hardware platforms on which 
    the apps runs: PCs and mobile devices. This hardware runs a mix of Windows, MacOS, 
    Linux, Android, iOS and other operating systems, which further complicates the 
    development effort. Developing client GUI apps for all of these hardware platforms 
    and their respective OSs is a much harder undertaking than developing a web frontend,
    which explains why desktop development has been surpassed by the web for the last
    decade or so. 

            
    2. APPLICATION SERVER TIER 
    On this tier, you would deploy the sub-program that does most of the processing in 
    the application. This sub-program is usually called the APP SERVER or the API and its 
    tier is called (confusingly enough) the APPLICATION SERVER. This tier is also either 
    owned by the business itself or rented from a cloud services company. The App Server 
    contains the Business Logic Layer, which is the brains of every project that is 
    architected with 3 or more tiers. Note that in most applications, the App Server also 
    contains the Data Access Layer.
    
    When the App Server receives user requests from the presentation server, it leaps 
    into action. If the requests require creating, reading, updating or deleting data, 
    the App Server will issue these orders to the the Data Access Layer. When the DAL 
    consults the data source and returns information, the App Server will process it and 
    pass on the final results on to the presentation tier, so that it can displayed to 
    the user.

                              
    3. DATA MANAGEMENT TIER     
    On this tier, you would deploy the primary data sources for the application and the
    sub-program that is responsible for DATA MANAGEMENT. The sub-program is often called 
    the DATABASE APPLICATION and runs on a tier called the DATABASE SERVER. The tier may
    also be called a REPOSITORY. The Database Application is probably commercial RDBMS 
    software like Microsoft SQL Server, SQLite or PostgreSQL, or an application that acts 
    as an abstraction layer over a database or a filesystem.
    
    Technically, in a three-tier application, the hardware for this tier would be a 
    DATABASE SERVER, but dedicated database servers are rarely used except in large 
    institutions or for complex applications. The Database Server is almost completely 
    passive; it waits for instructions from the DAL in the App Server.


If it's not already clear, the goal of using tiers,  is to carve out code from the main
project and tailor it to run a specific hardware or software platform.


AN ARCHITECTURAL PATTERN FOR INTERACTIVE SYSTEMS: MODEL-VIEW-CONTROLLER (MVC)

Model-View-Controller (MVC) is an architectural pattern that is widely used in web
programming. This project uses ASP.NET Core for building web pages; ASP.NET Core makes use 
of MVC for structuring web applications. Given the pervasiveness of MVC, you should know 
something about this pattern. 

Pablo Pastor introduces MVC, its history and its purpose in a blog post[4]:


    MVC is not a design pattern, it is an Architectural pattern that describes a way to 
    structure our application and the responsibilities and interactions for each part 
    in that structure.

    It was first described in 1979 and, obviously, the context was a little bit different. 
    The concept of web application did not exist. Tim Berners Lee sowed the seeds of World 
    Wide Web in the early nineties and changed the world forever. The pattern we use today 
    for web development is an adaptation of the original pattern.

    The wild popularization of this structure for web applications is due to its inclusion 
    in two development frameworks that have become immensely popular: Struts and Ruby on 
    Rails. These two environments marked the way for the hundreds of frameworks created 
    later.


If you check the 'Architectural Patterns' section of this file, you'll note that MVC is an
architectural pattern that falls under the architectural style of Interactive Systems. 
Interactive Systems are computer systems (a bundle of hardware and software) that has lots
of interaction between humans and the computer system. Desktop and laptop PCs and mobile 
devices are good examples of interactive systems. Embedded devices, for instance in your 
car's engine or in a factory's conveyor belt are examples of systems with relatively 
little human-computer interaction. Interactive applications are things like games, word 
processors, CLI apps; all of them take substantial user input as part of their normal 
functioning.

Interactive systems and applications are designed to respond to human requests. This is 
where MVC comes in: It appears to be an architectural pattern that best suited to 
organizing the layers in an interactive application. All interactive applications are 
similar, but not identical to one another. 

MVC is often used to structure the presentation tier in larger applications, but in 
smaller applications, it can be used to structure the presentation, business logic and
data access layers.


THE COMPONENTS OF MODEL-VIEW-CONTROLLER 

MVC's goal is to separate the following responsibilities in an application into three 
distinct layers:

    1. Model
    2. View
    3. Controller

The Model defines data and stores it, the View presents data to the user, and the 
Controller handles requests and returns responses.

It's important to note that MVC's layers do not directly correspond to the Multitier
architecture's layers, i.e. Model, View and Controller do not directly map on to the 
Presentation layer, Business Logic Layer and Data Access Layer. Keep this is mind to 
avoid confusion. 

MVC has other differences to the Multitier Architecture. In the multi-tier architecture, 
communication goes linearly through layers/tiers: the client tier cannot directly 
communicate with the Data Access tier, it has to pass messages through the Business logic 
tier. However, in MVC, the layers interact in a triangular structure, as shown below.

The diagram below portrays the functioning of the MVC pattern. To fully understand it, 
read the explanations below the diagram. To decipher the diagram, start with the User:


                                     +-------------------------------------------------------------------------+
                                     |                                                                         |
                                     |                                                                         |
                                     |                                                                         |
                                     |                              AN MVC PROGRAM                             |
                                     |                                                                         |
                       [REQUESTS]    |                                                                         |
                    The User issues  |                                                                         |
                    orders to the    |                                                                         |
                    program through  |                       The View sends user input                         |
                    the UI (View)    |                           to the Controller                             |
+-----------------+                  |  +-----------------+                              +-----------------+   |
|                 | +-----------------> |                 | +--------------------------> |                 |   |
| THE CLIENT/USER |                  |  |       VIEW      |                              |    CONTROLLER   |   |
|                 | <-----------------+ |                 | <--------------------------+ |                 |   |
+-----------------+                  |  +-----------------+                              +-----------------+   |
                    Information is   |                       The Controller sometimes                          |
                    presented to     |     ^                 updates the View directly                  +      |
                    the User via     |     |                                                            |      |
                    the User         |     |                                             [MANIPULATES   |      |
                    Interface (View) |     |                                              MODELS]       |      |
                      [RESPONSES]    |     | [UPDATES VIEW]                              The Controller |      |
                                     |     | When the                                    responds to    |      |
                                     |     | Models in the +---------------------------+ the user       |      |
                                     |     | Database      |                           | request by     |      |
                                     |     | change, the   |     DATA ACCESS LAYER     | operating on   |      |
                                     |     | View gets     |                           | Model objects  |      |
                                     |     | auto-updated  |     +---------------+     | in the Database|      |
                                     |     +-------------+ |     | MODEL OBJECTS |     | <--------------+      |
                                     |                     |     |    (IN THE    |     |                       |
                                     |                     |     |   DATABASE)   |     |                       |
                                     |                     |     +---------------+     |                       |
                                     |                     +---------------------------+                       |
                                     |                                                                         |
                                     +-------------------------------------------------------------------------+


I'm going to explain these layers plus a fourth layer, ViewModel, that is often used in
ASP.NET Core projects. Note that the explanation below is tailored to ASP.NET Core; other
MVC frameworks may be different.


1. Model: The model layer is probably the simplest layer in MVC. The model represents the
   data, but does nothing else. The model is independent of the View and the Controller.
   When it comes to models, there is distinction to be made between Model classes and
   Model objects. Be aware of the difference between the two terms. Model classes are 
   templates for Model objects. Model objects contain most of the business-related data 
   in an MVC application. Model classes and Model object live separately; Model classes 
   are defined in the Models folder of the Common project, whereas Model objects live in 
   a Data Store such as a Database or File system. 

   Model classes are Plain Old Class Objects (POCO) that define important business entities 
   for your application. A model class represents the knowledge that the application needs 
   to know about a certain business entity. Therefore, a Model class needs to be designed 
   to capture information important to each entity. When designing a model class, it's 
   important to be selective about the information you capture.
   
   In a Calendar program, things like the Day, Alarms, Contacts etc. would be the Business 
   entities. To a Day class, things like Date, Day of the Week, Scheduled events etc., 
   would qualify as important information. So, these things will be represented as class 
   properties. What kind of information should be left out? Here's a rather extreme 
   example: you probably won't need a property that captures how many days have passed 
   since the death of Julius Caesar. It would not make much sense in a Calendar app as 
   your users probably don't care about this piece of information.
   
   In a model class, you can choose to add Data Annotations to each property to place 
   limitations on the values accepted by a property. For example, you can use C#'s 
   [PhoneNumber] annotation to ensure that all values for the PhoneNumber property follow 
   the standard. All model objects instantiated from this class have restrictions on the 
   value for the phone number: it is limited a certain length, and allows only integers, 
   brackets and dashes.
   
   Model classes do very little besides serve as a template for business entities. When
   the Controller layer, is instructed by a user or its internal logic to create business 
   entities, it will use the pre-defined Model classes as templates for these objects. 
   
   Once these model objects have been created, they are passed back and forth between the 
   Views, Controllers and Database. Therefore, Model objects are the drops of water in a 
   river of data that flows throughout the application. To display information to the user, 
   the Controller will send model objects to the View layer. To persistently store data, 
   the Controller will send model objects to the program's database/file system. Model 
   objects will live there, and when needed, the Controller layer will consult or modify them.
   
   The Common library contains the Model classes for HRSP.
   

2. View: "A view is a (visual) representation of its model. It would ordinarily highlight
   certain attributes of the model and suppress others. It is thus acting as a presentation
   filter."[5] 
   
   The View layer is the presentation layer; it controls how data from model objects are
   formatted and presented to the user. The View provides a variety of ways to present data 
   it receives from Model objects, subject to user direction. With information it receives 
   from the View, the user use the UI (the View) to issue orders to the program. The View 
   can be an HTML webpage, a GUI, a text-based UI, Razor Views etc.

   HRSP does not use standard ASP.NET Core Views due to the fact that it uses the Console
   to display text-based information to the user instead of HTML-based web pages. 
   Hotel-Client contains the View layer of this application.


3. ViewModel: This layer, strictly speaking, is not a part of MVC. It belongs to a variant 
   of MVC, the Model-View-ViewModel (MVVM) pattern. However, as MVC/MVVM is not an 
   either/or choice[6], I'm introducing this concept here. In MVVM, ViewModels take up the 
   role of Controllers, but do not necessarily replace them completely. See the sixth 
   source for more details. Here is an explanation of what ViewModels do from an MSDN 
   article[7]:
   

       The ViewModel class, which is the bridge between the view and the model. Each View
       class has a corresponding ViewModel class. The ViewModel retrieves data from the 
       Model and manipulates it into the format required by the View. It notifies the View 
       if the underlying data in the model is changed, and it updates the data in the Model 
       in response to UI events from the View.

       
   However, in ASP.NET Core, viewmodels appear to be passive containers. There are two 
   ways to send information to the user in an ASP.NET Core MVC application: have the 
   Controller send Models directly to the View, which displays it to the user OR the have 
   Controller load into the Viewmodel only the parts of the Model that the View requires, 
   and then send that to the View. 
   
   Though the first method is easier, in ASP.NET Core MVC, it is a best practice to use 
   viewmodels as intermediaries between models and views. There are two reasons for this: 
   The View() method can usually accept only a single model or Viewmodel object and 
   secondly, Viewmodels let you tailor models so that only required model data gets sent 
   to the View. For these reasons, only necessary Models are packed as properties into a
   Viewmodel, which is then sent to the View(). You should use a Viewmodel even if you 
   need to send only a single model to the View(), as this is something that could change 
   in the future. For more information, see the project 'ASPNETCore WebApp 1A - Routing'.

   HRSP does not use any Viewmodels.


4. Controller: The controller layer is the brain of the application. It consists of 
   controller class(es) whose methods respond to incoming requests. Also, the business 
   rules and the business logic of the application are sometimes defined and applied in 
   controller class methods. 
   
   When a user makes a request via the View, it gets passed to a controller whose 
   method is designated to respond to that particular request. Controllers will process, 
   interpret and validate incoming requests. In ASP.NET Core, Controllers do much of the 
   in-program communication and handling of data by doing things like routing, 
   authentication, authorization, request validation and redirection, response handling, 
   model formatting and generation etc.  Once that is done, it is their job to query and 
   modify model objects in the database and create or update Views to fulfill the user 
   request. By doing these things, this layer controls and directs application flow.

   To compare the Controller layer to Multier Architecture's layers for a moment, the 
   Controller layer seems to combine Multitier's Business Logic and Data Access Layers.
   That might be a okay for small applications, but for mid-to-large sized applications, 
   combining two layers like that will lead to confusion and complexity. For more complex
   programs, you'll want to keep your Controllers rather lean and move your business logic
   into a separate software component, such as the Model layer. 


PROS AND CONS OF THE MVC PATTERN

This list is taken from Pg 194-195 of 'Pattern-Oriented Software Architecture For 
Dummies'[1]:


    Benefits

    The flexibility of decoupling the data (model) from the output (view) and input 
    (controller) is the primary benefit of the MVC architecture. You’ll see this over 
    and over again in the following list of benefits:

    ✓ The model is strictly separated from the UI components in this architecture. You 
      can use the same data to supply multiple views.

    ✓ Changes to the data in the underlying model are reflected in all the views 
      automatically. This is possible because there is a single source of the data being 
      displayed.

    ✓ You can change the view and controller elements of the system without changing the 
      data model. This capability increases the flexibility of the system. You can keep the 
      underlying model element consistent and intact, and exchange the view and controller 
      components of the system.

    ✓ Because the UI code is independent of the model, when you need to make major changes 
      in the UI section, the underlying data doesn’t need to change. This kind of major 
      change can result from moving the system to new hardware or to hardware that has a 
      different look and feel.

    ✓ The views don’t interact. As a result, you can change an individual view without 
      having to make changes in the other views.

    ✓ MVC architectures can be used as frameworks to be used and extended in other 
      situations. The three components are related yet independent, which simplifies 
      maintenance and evolution.

    Liabilities

    In addition to the benefits, liabilities come along with using MVC. You must balance 
    these liabilities with the benefits when you design your system:

    ✓ Complexity is increased by separating the three components of MVC. You have more 
      components to build and maintain than you would if you’d designed the system as a 
      monolith. Unless you need flexibility in the UI or the views, MVC may add more 
      overhead than your application really needs.

    ✓ Changes to the model are published to all the views that subscribed for them. The 
      number of recipients of change-notification messages increases as the system gets 
      bigger. To overcome this liability, consider the big picture when you design the 
      scope of changes that result in update publications...

    ✓ The controller and the views grow closer with time. Even though the components are 
      individuals, they have strong relationships that limit your ability to reuse one 
      component without the others. As the system grows and evolves, views will be added 
      to the system, along with resulting enhancements to the controller that allow the 
      views to be selected and controlled. Because the components are so intertwined, 
      reusing only the controller or only the views is more difficult than reusing the
      controller and views together. The relationship also limits your ability to insert
      new versions of either component, because the new version must be adapted to support 
      the component that isn’t being replaced.

    ✓ The controller and view components know quite a lot about the model. Changes in the
      model may require changes in both of the other two components. Adding indirection 
      helps mitigate this liability, however, as I discuss in the implementation section 
      (“Step 4: Design and build the controllers”) later in this chapter.

    ✓ Inefficient data access can result because of the separation of views and model data 
      and the need to go through the model’s API. This problem is especially apparent if the 
      view must request unchanged data from the model frequently. You can improve 
      responsiveness, however, by designing the view to cache data.

    ✓ Both controller and view components require changes when they’re ported to a new 
      system. These components contain some platformdependent code, so when the components 
      are ported to a new system, the platform-dependent code requires changes.


THE ART OF ABSTRACTION: SEPARATING SOFTWARE INTO LAYERS AND TIERS

ABSTRACTION LAYERS

Hanmer defines the concept of Abstraction on Page 30[1]:


    Abstraction is the ability to extract the common, general parts from a particular 
    entity. You use abstraction to define a common component that will be adapted to several 
    specific situations in your system.


From this idea, comes the concept of abstraction layers. The wikipedia article on 
Abstraction Layer explains it as follows[]: https://en.wikipedia.org/wiki/Abstraction_layer  


    In computing, an abstraction layer or abstraction level is a way of hiding the 
    implementation details of a particular set of functionality, allowing the separation 
    of concerns to facilitate interoperability and platform independence. Examples of 
    software models that use layers of abstraction include the OSI model for network 
    protocols, OpenGL and other graphics libraries.
    
    In computer science, an abstraction layer is a generalization of a conceptual model 
    or algorithm, away from any specific implementation. These generalizations arise from
    broad similarities that are best encapsulated by models that express similarities 
    present in various specific implementations. The simplification provided by a good 
    abstraction layer allows for easy reuse by distilling a useful concept or design 
    pattern so that situations where it may be accurately applied can be quickly 
    recognized.
    
    A layer is considered to be on top of another if it depends on it. Every layer can 
    exist without the layers above it, and requires the layers below it to function. 
    Frequently abstraction layers can be composed into a hierarchy of abstraction levels. 
    The OSI model comprises seven abstraction layers. Each layer of the model 
    encapsulates and addresses a different part of the needs of digital communications, 
    thereby reducing the complexity of the associated engineering solutions. 


What does that mean in practice? gb2d offers a concrete example of an abstraction layer[]:
https://softwareengineering.stackexchange.com/questions/223947/what-is-an-abstraction-layer


    Often an abstraction layer is commonly used to 'abstract' away detail.
    
    Say you had a program for moving money around between different banks. There is a 
    function for moving money to BankA, and a different function for moving money to 
    BankB and so on. The different functions might exist because the information that 
    different banks request varies (As a simple example maybe one requests the senders 
    first name and surname, and another requests the senders first initial and surname).

    Your functions might be:

    
        MoveMoneyToBankA(amount, accountNo, senderFirstName, senderSurname)
        {
            ... Code to move money to bank A
        }
        
        MoveMoneyToBankB(amount, accountNo, senderFirstInitial, senderSurname)
        { 
            ... Code to move money to bank A
        }


    To abstract away all the different things a program needs to think about when 
    communicating with different banks, an abstration layer might be implemented by 
    adding the function 'MoveMoneyToBank':
    
    
        MoveMoneyToBank(amount, accountNo, senderFirstName, senderSurname, bankName)
        {   
            ... If bank name = 'BankA' call MoveMoneyToBankA
            ... If bank name = 'BankB', find senderFirstInitial using senderFirstName, 
                and call 'MoveMoneyToBankB'
        }


    So what you have done here is abstracted away the detail that needs to be managed 
    when communicating with two different banks. A programmer can now just use the 
    general MoveMoneyToBank function, and not have to think about the different 
    requirements of each bank.
    
    In reality, this might not just be functions with in the same program, but even 
    different projects within the same solution, or a new software project that draws in 
    lots of components and deals with the complexity of working with all the separate 
    components to achieve a common goal.


CREATING ABSTRACTION LAYERS USING TIERS AND LAYERS

Hanmer explains how tiers and layers are abstractions. Why do we need abstractions?


    What these different ways of layering the system [Tiers and Layers] have in common is 
    that they’re abstractions. An abstraction is a way of describing something in general 
    terms that leaves out the details of any specific implementation. In the examples in 
    the preceding section, the abstraction is a general layer that doesn’t describe how the 
    functionality is implemented or even precisely what it does; those details are 
    abstracted away.

    ...you see that abstraction is one of the important techniques that help you build 
    better architecture. Abstractions are important to software architecture because they 
    allow you to talk about what the system does in general terms before you’ve worked 
    out all the low-level details. 

    In the same way, the three-tier architecture separates the functionality by 
    abstractly grouping the presentation server and keeping its functionality separate 
    from the functionality of the database servers. This is done because they have 
    different processing or storage needs, and the boundary of an abstraction can be 
    drawn around the layers.

    Being able to abstract the essence of a functionality and project it onto the 
    solution are important skills that you must have as a software architect.


Layers and tiers are used to deliberately create a structure for the project. If this 
is done correctly, changes made to a layer affect only that layer and the same applies to 
tiers. In software projects with no pre-planned architecture, there really isn't any 
structure. In such programs, what should be distinct functions, features, layers and tiers 
are jumbled into a tangled web of code. The architecture of such projects is called a 
'Big Ball of Mud', aka 'Spaghetti Code'. Changing UI code can cause unpredictable failures
in Business Logic or Data Access code. This what happens to a project that does not plan 
out its structure, architecture, architectural style, the specific architectural pattern 
and other such details during the Design phase of the project.


HOW DO LAYERS AND TIERS HELP?

The number of layers and tiers in a software project is variable and depends on the 
project's size and needs, but the number of layers and tiers usually increase with a 
program's size and complexity. 

What's the point of using layers and tiers? Rockford Lhotka explains[3]:

    Why do we layer software? Primarily to gain the benefits of logical organization and 
    grouping of like functionality. Translated to tangible outcomes, logical layers offer 
    reuse, easier maintenance and shorter development cycles. In the final analysis, proper 
    layering of software reduces the cost to develop and maintain an application. Layering 
    is almost always a wonderful thing! 

    Why do we deploy layers onto multiple tiers? Primarily to obtain a balance between 
    performance, scalability, fault tolerance and security. While there are various other 
    reasons for tiers, these four are the most common. The funny thing is that it is almost 
    impossible to get optimum levels of all four attributes – which is why it is always a 
    trade-off between them.

He continues in the article and makes a few practical comments about tiers:

    Tiers imply process and/or network boundaries. A 1-tier model has all the layers running 
    in a single memory space (process) on a single machine. A 2-tier model has some layers
    running in one memory space and other layers in a different memory space. At the very 
    least these memory spaces exist in different processes on the same computer, but more 
    often they are on different computers. Likewise, a 3-tier model has two boundaries. 
    In general terms, an n-tier model has n-1 boundaries.
    
    Crossing a boundary is expensive. It is on the order of 1000 times slower to make a 
    call across a process boundary on the same machine than to make the same call within 
    the same process. If the call is made across a network it is even slower. It is very 
    obvious then, that the more boundaries you have the slower your application will run, 
    because each boundary has a geometric impact on performance.

    Worse, boundaries add raw complexity to software design, network infrastructure, 
    manageability and overall maintainability of a system. In short, the more tiers in an 
    application, the more complexity there is to deal with – which directly increases the 
    cost to build and maintain the application.
    
    This is why, in general terms tiers should be minimized. Tiers are not a good thing, 
    they are a necessary evil required to obtain certain levels of scalability, fault 
    tolerance or security.
    
    As a good architect you should be dragged kicking and screaming into adding tiers to 
    your system. But there really are good arguments and reasons for adding tiers, and 
    it is important to accommodate them as appropriate.
    
    The reality is that almost all systems today are at least 2-tier. Unless you are using 
    an Access or dBase style database your Data layer is running on its own tier – typically 
    inside of SQL Server, Oracle or DB2. So for the remainder of my discussion I’ll primarily 
    focus on whether you should use a 2-tier or 3-tier model...

    ...the question remains whether to configure an application for 2 or 3 tiers. 
    
    Ultimately this question can only be answered by doing a cost-benefit analysis for 
    your particular environment. You need to weigh the additional complexity and cost of 
    a 3-tier deployment against the benefits it might bring in terms of scalability, fault 
    tolerance or security.


HOW LAYERS AND TIERS ARE USED IN APPLICATIONS

This is a diagram of a monolithic application:


+--------------------------------------------------------------------------------------------+
|                                                                                            |
|                                    THE APPLICATION                                         |
|                                                                                            |
|  +--------------------------------------------------------------------+                    |
|  |                                                                    |    +------------+  |
|  |                          APPLICATION COMPONENTS                    |    |            |  |
|  |                                                                    |    |            |  |
|  |   +--------------+       +---------------+     +---------------+   |    |            |  |
|  |   | PRESENTATION | +---> |   BUSINESS    | +-> |  DATA ACCESS  | +----> |  DATABASE  |  |
|  |   |    LOGIC     | <---+ |     LOGIC     | <-+ |     LOGIC     | <----+ |            |  |
|  |   +--------------+       +---------------+     +---------------+   |    |            |  |
|  |                                                                    |    |            |  |
|  |                                                                    |    +------------+  |
|  +--------------------------------------------------------------------+                    |
|                                                                                            |
+--------------------------------------------------------------------------------------------+

                                    RUNS ON A SINGLE MACHINE


To avoid spaghetti code, the program's code has been partitioned into three layers, 
modelled after the layers in N-tier. However, all layers are tightly coupled and live on
the same machine. All three layers are packaged in a single executable and run on the 
same machine. That makes this application's architecture 1-tier.

In such a tightly integrated application, changing one layer will probably require changes 
to the other layers. As the program is designed for a single machine, scaling the number of
processors is probably not possible. For the same reason, the portability factor of this 
design is low. Nevertheless, it may make sense to use this design for small applications
that don't handle much traffic or need much resources.

In a a 2-tier application, the program is usually separated into two halves:
a client and a server. These programs run on two separate machines:


+------------------------------------------------+ +-----------------------------------------+
|                CLIENT APPLICATION              | |          SERVER-SIDE APPLICATION        |
|                                                | |                                         |
| +--------------------------------------------+ | | +---------------------+                 |
| |                   LAYER 1                  | | | |  DATA ACCESS LAYER  |  +------------+ |
| |                                            | | | |                     |  |            | |
| | +----------------+      +----------------+ | | | |  +---------------+  |  |            | |
| | |  PRESENTATION  | +--> |    BUSINESS    | +------> |  DATA ACCESS  | +-> |  DATABASE  | |
| | |     LOGIC      | <--+ |     LOGIC      | <------+ |     LOGIC     | <-+ |            | |
| | +----------------+      +----------------+ | | | |  +---------------+  |  |            | |
| |                                            | | | |                     |  +------------+ |
| +--------------------------------------------+ | | +---------------------+                 |
+------------------------------------------------+ +-----------------------------------------+

        RUNS ON USER'S PC OR WEB SERVER                RUNS ON APPLICATION/DATABASE SERVER


In this variation of the 2-tier application, the Presentation and Business Logic layers are
combined into the client. The client would probably run on a user's machine while the Data 
Access Layer and the Database live on a server. Another variation of this application would 
bundle the Business Logic and Data Access Layer together. 

This application is less tightly coupled than the 1-tier application, so making changes like
swapping out the database become easier. The Presentation and Business Logic layers are still
coupled, making it likely that any changes to one layer could affect the other. 

In a 3-tier application, you would have, three programs running on three different machines: 
a client application running on the user's PC or perhaps on a web server, an App server 
program (containing the Business Logic Layer) running on an Application Server the Database
backend will run on a Database Server:


+--------------------+  +-------------------------------------------+  +----------------------+
| CLIENT APPLICATION |  |             APP SERVER/API                |  | DATABASE APPLICATION |
|                    |  |                                           |  |                      |
|  +--------------+  |  |  +--------------+        +-------------+  |  |    +------------+    |
|  |              |  |  |  |              |        |             |  |  |    |            |    |
|  | PRESENTATION |  |  |  |   BUSINESS   |        | DATA ACCESS |  |  |    |            |    |
|  |    LAYER     |  |  |  |    LAYER     |        |    LAYER    |  |  |    |            |    |
|  |              | +----> |              | +----> |             | +------> |            |    |
|  |  containing  |  |  |  |  containing  |        | containing  |  |  |    |  DATABASE  |    |
|  |              |  |  |  |              |        |             |  |  |    |            |    |
|  | PRESENTATION | <----+ |   BUSINESS   | <----+ | DATA ACCESS | <------+ |            |    |
|  |    LOGIC     |  |  |  |    LOGIC     |        |    LOGIC    |  |  |    |            |    |
|  |              |  |  |  |              |        |   (+ ORM)   |  |  |    |            |    |
|  +--------------+  |  |  +--------------+        +-------------+  |  |    +------------+    |
|                    |  |                                           |  |                      |
+--------------------+  +-------------------------------------------+  +----------------------+

  RUNS ON USER'S PC              RUNS ON AN APPLICATION SERVER           RUNS ON A DATABASE
    OR WEB SERVER                                                              SERVER


In this case, each layer has its own tier, and thus, each layer runs on its own machine. All
layers are completely uncoupled from each other, making it easier to refactor and expand all
elements of the application.



ARCHITECTURE OF THE HOTEL-SERVER PROJECT

This project pairs the ideas of tiers from the Multitier Architecture with layers from the
MVC architectural pattern. This is not unusual, as N-Tier Architecture is often used in 
conjunction with the MVC pattern for client-server applications.

This project, Hotel Reservation System Project (HRSP), is divided into 2 tiers and a 
library component:


    1. Hotel-Client,            (Client Frontend)
    2. Hotel-Server, and        (Application Server)
    3. Common                   (Shared Library)


Hotel-Client is the client program, Hotel-Server is the Application Server and Common is a 
library that stores files shared by these two programs. A copy of Common will be shipped 
with all copies of Hotel-Client and Hotel-Server.

Here is a diagram that portrays HRSP's structure: 


                                   RUNS ON USER'S PC

                                +---------------------+
                                | CLIENT APPLICATION  |
                                |                     |
                                |  +---------------+  |
                                |  |    COMMON     |  |
                                |  |               |  |
                                |  | Model Classes |  |
                                |  +---------------+  |
                                |                     |
                                |       ^    +        |
                                |       |    |        |
                                |       +    v        |
                                |                     |
                                |  +---------------+  |
                                |  | HOTEL-CLIENT  |  |
                                |  |               |  |
                                |  |  View Layer   |  |
                                |  +---------------+  |
                                |                     |
                                |       +    ^        |
                                +---------------------+
                                        |    |
                                        |    |
                                        |    |
                                +-------------------------------------------+
                                |       v    +                              |
                                |                                           |
                                |  +---------------+     +---------------+  |
                                |  | HOTEL-SERVER  | +-> |    COMMON     |  |
                                |  |               |     |               |  |
                                |  |  Controllers  | <-+ | Model Classes |  |
                                |  +---------------+     +---------------+  |
                                |                                           |
                                |       +    ^                              |
                                |       |    |                              |
                                |       v    +             APP SERVER       |
                                |                           PROGRAM         |
                                |  +---------------+                        |
                                |  |   DATABASE    |                        |
                                |  |               |                        |
                                |  | Model Objects |                        |
                                |  +---------------+                        |
                                |                                           |
                                +-------------------------------------------+

                                         RUNS ON APPLICATION SERVER


Let's take a look at the structure of this project:

TIERS

1. Presentation Tier

In HRSP, the frontend role falls to Hotel-Client, which is a program that let the user 
communicate to HRSP application. Users will issue orders and make requests of HRSP through 
Hotel-Client, which will pass them on to the heart of the application, the Hotel-Server 
program. If HRSP were deployed in the real world, many copies of Hotel-Client would run on
desktop and laptop computers that serve Hotel front desk clerks and their managers. 
Therefore, the presentation tier for Hotel-Client is intended to be PCs.

2. API/App Server

In HRSP, Hotel-Server is the Application Server. The Business Logic Tier's hardware platform 
is usually a physical (or virtual) SERVER. App Server programs run on these servers, 
listening for communications from the frontend. Client frontends pass User requests over 
the internet to the App Server program to do the processing.

3. Data Tier

For this project, Hotel-Server also contains the Data Access Tier. 


LAYERS

This project uses a modified MVC pattern to structure the layers of the application. More
specifically, it uses Models and Controllers but does away with traditional Views. Instead
of HTML/CSS/Javascript Views, HRSP deploys a console application to the user's PC. Here 
are the three layers in HRSP:

1. Models

Model classes are contained in the library called Common. It will be compiled down to a 
library which will be shipped with both Hotel-Client and Hotel-Server. Model objects will 
be stored in a PostgreSQL database. 


2. Views

This layer is contained in Hotel-Client. It authenticates users, accepts user input, 
validates it and passes it on to Hotel-Server for processing. 

3. Controllers

The Controller layer can be found in Hotel-Server. It does both business logic and 


This layer and the Data Access Layer is part of Hotel-Server. The BLL recieves requests 
from the presentation layer and responds to user input by doing all the processing needed 
to fulfill their requests. It makes calls to the Data Access Layer if it needs to make
changes to persistent data. 

3. Data Access Layer

The DAL contains the Database and code that 



SOURCES

1: Pattern-Oriented Software Architecture For Dummies (Robert Hanmer, 2013)
2: https://en.wikipedia.org/wiki/Distributed_computing
3: https://en.wikipedia.org/wiki/Client%E2%80%93server_model