1. INTRODUCTION TO DISTRIBUTED COMPUTING ARCHITECTURES

In the previous article, 1.1 Architectures & Patterns.txt, I introduced architectures and
concepts related to them. This article will consider a narrower class of ideas - 
architectural concepts required to develop web applications. As web applications need a 
distributed architecture, this will be the focus in this article. 

Here are the topics that will be explored: 


    1. Distributed Computing and an Introduction to DC Architectures
    2. A 2-Tier Distributed Architecture: The Client-Server Model
    3. A 3+ Tier Distributed Architecture: Multitier/N-Tier
    4. An Architectural Pattern for Interactive Systems: Model-View-Controller (MVC)


Finally, after discussing distributed computing architectures and the MVC pattern, I will
analyze and discuss the structure and architecture, and architectural patterns used in 
Hotel-Reservation-System.


2.1 DISTRIBUTED COMPUTING: CONCEPTS

Here is a definition for Distributed Computing[1]:


    Distributed computing is a field of computer science that studies distributed systems. 
    A distributed system is a system whose components are located on different networked 
    computers, which then communicate and coordinate their actions by passing messages to 
    each other. The components interact with each other in order to achieve a common 
    goal... Examples of distributed systems... [include] ...massively multiplayer online 
    games to peer-to-peer applications. 

    A computer program that runs within a distributed system is called a distributed 
    program (and distributed programming is the process of writing such programs). There 
    are many different types of implementations for the message passing mechanism, 
    including pure HTTP, RPC-like connectors and message queues.


When one has to design software that works over any network, such as the internet, it 
usually cannot be designed as a single monolithic application. Why? Because in a 
networked program, work is not being done by a single monolithic program that runs on a 
single computer. 

Rather, web applications are often comprised of two, three or more components, which are 
organized into layers and physically separated into tiers. The application's layers live 
within one of its tiers. The application's tiers are standalone sub-programs with a 
designated set of responsibilities. Each sub-program is usually designed to run on a 
separate machine, but all sub-programs can run on the same computer if needed. However,
this usually happens only in development and testing environments.

That's right, as non-networked programs can choose a monolithic architecture or not as
the developers please, the standout difference is that web applications must almost 
always be designed with multitier architectures. A web application can have several 
tiers, such as: a Client Application, an App Server and a Database Server. These 
sub-programs usually run on separate machines and communicate with each other over the 
network (the internet, institutional intranets etc.) to coordinate towards 
accomplishing the application's purpose.

As web applications tend to have multiple layers and tiers that are spread out over 
multiple machines, its resources and duties are distributed over multiple devices. Hence
the name distributed computing. Therefore, when a programmer designs a web application, 
she has to design the application to work over a network, which requires being broken up 
into multiple layers and sub-programs.

At this point, let's talk about functional layers. Most web applications recognize that 
they have at least three major groupings of functions (layers):


    * User Interface
    * Application Processing
    * Data Management


2.2 DISTRIBUTED COMPUTING: DISTRIBUTED ARCHITECTURES

When designing a distributed application, you have to choose a distributed architecture
for it. On top of that, you have organize its code into layers and tiers. Deciding which
tier gets which layer is not a precise art and has some room for maneuvering. 

Distributed architectures are usually categorized by the number of tiers they have. 
Presented below, the Wikipedia article on this topic provides a brief explanation for a 
number of basic architectures[1] This list of distributed architectures distinguishes 
between architectures on the basis of the number of tiers they have:


    * CLIENT-SERVER: architectures where smart clients contact the server for data then 
      format and display it to the users. Input at the client is committed back to the 
      server when it represents a permanent change. [2-tier architecture]

    * THREE-TIER: architectures that move the client intelligence to a middle tier so 
      that stateless clients can be used. This simplifies application deployment. Most 
      web applications are three-tier. [3-tier architecture]

    * N-TIER: architectures that refer typically to web applications which further forward 
      their requests to other enterprise services. This type of application is the one 
      most responsible for the success of application servers. [3+ tier architecture]

    * PEER-TO-PEER: architectures where there are no special machines that provide a 
      service or manage the network resources. Instead all responsibilities are uniformly
      divided among all machines, known as peers. Peers can serve both as clients and as
      servers. [This architecture is different from the other three. It can potentially
      have millions of peers.]


This list is presented in a rather confusing way, but the gist of it is that there are
two main types of distributed architectures: Multitier Architecture and Peer-to-Peer
Architectures. 

Multitier (also called N-Tier) is a distributed architecture that is divided into two or 
more parts. The Client-Server and Three-Tier architectures are considered variants of 
Multitier architecture. Client-Server is a 2-tier architecture, where the application is 
split into two parts, Client and Server. Three-Tier architecture has three tiers and 
usually they are: UI Server, App Server and Database Server.

P2P architectures are unlike the other architectures. In the other three traditional
distributed architectures, the consumption of resources and supply of duties is divided 
by tier. This means that every part of an Multitier application, regardless of whether it 
has two, three or more tiers, has a special duty, a role that only it can perform for the 
application. In a client-server architecture, the client acts as a conduit, displaying 
information and taking requests from the user. The server's duty is do the processing and 
data management. 

A P2P application is different; it is a monolithic program that contains all or most 
modules of the application. For this reason, P2P peers are said to be equally privileged 
because every peer has the same capabilities and responsibilities. A peer can act as 
both client and server and does processing on the local machine. The results of its work 
can be shared across a network to peers running on other machines. The most famous 
example of P2P programs are Torrenting programs.


3.1.1 CLIENT-SERVER MODEL (2-TIER ARCHITECTURE)

The wikipedia article for the CLIENT-SERVER MODEL architecture[3] provides this 
explanation:


    The client–server model is a distributed application structure that partitions tasks 
    or workloads between the providers of a resource or service, called servers, and 
    service requesters, called clients. Often clients and servers communicate over a 
    computer network on separate hardware, but both client and server may reside in the
    same system. A server host runs one or more server programs which share their 
    resources with clients. A client does not share any of its resources, but requests 
    a server's content or service function. Clients therefore initiate communication 
    sessions with servers which await incoming requests. Examples of computer 
    applications that use the client–server model are Email, network printing, and the 
    World Wide Web.


Programs with a client-server architecture have two parts:

    * CLIENT: The client is the frontend; it's the user interface through which the user
      interacts with the application. When the user wants a resource or wants the program
      to do something, she will pass these instructions to the client. The client will 
      send these requests to the server. 

    * SERVER: The server will respond to client requests by sending back resources or 
      doing the operation that the user asked for. The server in this model handles two
      functions, application processing and data management.


HRSP needs two tiers, a client and an application server, so it is structured in a 
client-server architecture. 
    
    
3.1.2 THE MULTITIER/N-TIER ARCHITECTURE (3+ TIER ARCHITECTURE)

Programs with three or more tiers usually use the multitier architecture to organize 
code. The multi-tier architecture separates software along two axes, namely layers 
and tiers. Recall that:

Tier: A tier physically divides software into modules, components or libraries.
Layer: A layer logically organizes software elements by function. 

This section will explain the layers and tiers in the traditional three-layer and 
three-tier architecture of web applications. In this architecture, the layers are tiers, 
i.e. each layer in the application is a separate tier. As this is a traditional 
structure, it only serves as a guideline. Reality rarely deigns to completely conform to 
architectural theories, so you'll have to adapt architectures and patterns when designing 
your software solution.


LAYERS 

Let's discuss layers in detail first.  

Note that a layer exists independently of the layers above it, but depends on the 
functionality provided by the layers below it. The three traditional layers are:


    1. PRESENTATION LAYER
    This is the User Interface layer. It is the highest layer in the three-layer stack. 
    It contains all code related to the UI. This layer is charge of displaying program 
    data to the user and in turn, accepting their commands and passing them to the layer
    below (the Business Logic Layer) for execution. 
                             
                             
    2. BUSINESS LOGIC LAYER
    This is the domain logic layer; it contains business logic for your application. 
    The BLL does the work of processing user requests by performing operations on data 
    stored in the Data Access Layer. The Business Logic Layer will return the results of 
    these operations to the Presentation Layer, which will then display them to the user. 
    Note that the Business Logic Layer sits in the middle of the layer stack, communicating 
    to the UI layer above and the Data Access Layer below. 
                             
    3. DATA ACCESS LAYER
    This layer is the bottom of the stack and its job is to interface with a data source,
    such as a database or file system, to store, modify or retrieve persistent data.
    Upon request by the other two layers, it is DAL's job to convert data from a row of 
    fields in a database table into objects for their consumption. The DAL exposes APIs 
    to the Business Logic Layer that it can use to manipulate stored data, letting the 
    BLL Create, Read, Update and Delete data stored on this layer. 

                             
The goal of layers is to separate functionalities from each other. Presentation logic
should not entangled with Business logic or Data Management logic. LOOSE COUPLING


TIERS

Traditionally, there are three tiers, but once again, the actual number of tiers in your
project should depend on its scope and needs. Here are the traditional tiers:  
 
 
    1. PRESENTATION TIER
    On this tier, you would deploy the sub-program that presents information to and 
    receives input from Users. This module is frequently called the CLIENT or the 
    FRONT-END. It contains the presentation layer of the project; it is concerned with
    presenting information to the user and accepting directions from them via some type 
    of user interface (E.g. Graphical User Interface (GUI), Text-based User Interface 
    (TUI) etc.) 

    The client or frontend's native hardware platform (tier) is the PRESENTATION SERVER. 
    This is a server machine typically owned by the business or rented from a cloud 
    services provider (Amazon Web Services, Google Cloud Platform, Microsoft Azure etc.). 
    As the web is ubiquitous these days, WEB SERVERS are the most common presentation 
    tier. ASP.NET Core web apps would probably host their frontend on a web server. 
                            
    For web applications (websites), the web browser is typically the delivery mechanism. 
    If a user opens a browser and requests your website, that request will be forwarded 
    to your presentation server (a web server). The web server will pass on the request 
    to next tier, the App Server, which will return requested website data to the web 
    server. The web server will convert this data into a graphical interface and send it 
    back to the browser where it will be displayed to the user.

    The browser is a standards-based way to deliver web content, making it (relatively) 
    easy to develop for. The Amazon.com website's presentation tier are the web servers 
    that tasked with deliving this website to browsers. However, the web is only one of 
    many possible ways to display information to the user. Other presentation tiers 
    exist; if we talk about the Amazon Kindle reading app instead, then the presentation 
    tier is no longer the web server, it becomes the all the hardware platforms on which 
    the apps runs: PCs and mobile devices. This hardware runs a mix of Windows, MacOS, 
    Linux, Android, iOS and other operating systems, which further complicates the 
    development effort. Developing client GUI apps for all of these hardware platforms 
    and their respective OSs is a much harder undertaking than developing a web frontend,
    which explains why desktop development has been surpassed by the web for the last
    decade or so. 

            
    2. APPLICATION SERVER TIER 
    On this tier, you would deploy the sub-program that does most of the processing in 
    the application. This sub-program is usually called the APP SERVER or the API 
    (short for 'Application Programming Interface', because this program exposes an API) 
    and its tier is called (confusingly enough) the APPLICATION SERVER. This tier is also 
    either owned by the business itself or rented from a cloud services company. The 
    App Server contains the Business Logic Layer, which is the brains of every project 
    that is architected with 3 or more tiers. Note that in most applications, the 
    App Server also contains the Data Access Layer.
    
    When the App Server receives user requests from the presentation server, it leaps 
    into action. If the requests require creating, reading, updating or deleting data, 
    the App Server will issue these orders to the the Data Access Layer. When the DAL 
    consults the data source and returns information, the App Server will process it and 
    pass on the final results on to the presentation tier, so that it can displayed to 
    the user.

                              
    3. DATA MANAGEMENT TIER     
    On this tier, you would deploy the primary data sources for the application and the
    sub-program that is responsible for DATA MANAGEMENT. The sub-program is often called 
    the DATABASE APPLICATION and runs on a tier called the DATABASE SERVER. The tier may
    also be called a REPOSITORY. The Database Application is probably commercial RDBMS 
    software like Microsoft SQL Server, SQLite or PostgreSQL, or an application that acts 
    as an abstraction layer over a database or a filesystem.
    
    Technically, in a three-tier application, the hardware for this tier would be a 
    DATABASE SERVER, but dedicated database servers are rarely used except in large 
    institutions or for complex applications. The Database Server is almost completely 
    passive; it waits for instructions from the DAL in the App Server.


If it's not already clear, the goal of using tiers,  is to carve out code from the main
project and tailor it to run a specific hardware or software platform.


4. AN ARCHITECTURAL PATTERN FOR INTERACTIVE SYSTEMS: MODEL-VIEW-CONTROLLER (MVC)

Model-View-Controller (MVC) is an architectural pattern that is widely used in web
programming. This project uses ASP.NET Core for building web pages; ASP.NET Core makes use 
of MVC for structuring web applications. Given the pervasiveness of MVC, you should know 
something about this pattern. 

Pablo Pastor introduces MVC, its history and its purpose in a blog post[4]:


    MVC is not a design pattern, it is an Architectural pattern that describes a way to 
    structure our application and the responsibilities and interactions for each part 
    in that structure.

    It was first described in 1979 and, obviously, the context was a little bit different. 
    The concept of web application did not exist. Tim Berners Lee sowed the seeds of World 
    Wide Web in the early nineties and changed the world forever. The pattern we use today 
    for web development is an adaptation of the original pattern.

    The wild popularization of this structure for web applications is due to its inclusion 
    in two development frameworks that have become immensely popular: Struts and Ruby on 
    Rails. These two environments marked the way for the hundreds of frameworks created 
    later.


If you check the 'Architectural Patterns' section of this file, you'll note that MVC is an
architectural pattern that falls under the architectural style of Interactive Systems. 
Interactive Systems are computer systems (a bundle of hardware and software) that has lots
of interaction between humans and the computer system. Desktop and laptop PCs and mobile 
devices are good examples of interactive systems. Embedded devices, for instance in your 
car's engine or in a factory's conveyor belt are examples of systems with relatively 
little human-computer interaction. Interactive applications are things like games, word 
processors, CLI apps; all of them take substantial user input as part of their normal 
functioning.

Interactive systems and applications are designed to respond to human requests. This is 
where MVC comes in: It appears to be an architectural pattern that best suited to 
organizing the layers in an interactive application. All interactive applications are 
similar, but not identical to one another. 

MVC is often used to structure the presentation tier in larger applications, but in 
smaller applications, it can be used to structure the presentation, business logic and
data access layers.


THE COMPONENTS OF MODEL-VIEW-CONTROLLER 

MVC's goal is to separate the following responsibilities in an application into three 
distinct layers:

    1. Model
    2. View
    3. Controller

The Model defines data and stores it, the View presents data to the user, and the 
Controller handles requests and returns responses.

It's important to note that MVC's layers do not directly correspond to the Multitier
architecture's layers, i.e. Model, View and Controller do not directly map on to the 
Presentation layer, Business Logic Layer and Data Access Layer. Keep this is mind to 
avoid confusion. 

MVC has other differences to the Multitier Architecture. In the multi-tier architecture, 
communication goes linearly through layers/tiers: the client tier cannot directly 
communicate with the Data Access tier, it has to pass messages through the Business logic 
tier. However, in MVC, the layers interact in a triangular structure, as shown below.

The diagram below portrays the functioning of the MVC pattern. To fully understand it, 
read the explanations below the diagram. To decipher the diagram, start with the User:


                                     +-------------------------------------------------------------------------+
                                     |                                                                         |
                                     |                                                                         |
                                     |                                                                         |
                                     |                              AN MVC PROGRAM                             |
                                     |                                                                         |
                       [REQUESTS]    |                                                                         |
                    The User issues  |                                                                         |
                    orders to the    |                                                                         |
                    program through  |                       The View sends user input                         |
                    the UI (View)    |                           to the Controller                             |
+-----------------+                  |  +-----------------+                              +-----------------+   |
|                 | +-----------------> |                 | +--------------------------> |                 |   |
| THE CLIENT/USER |                  |  |       VIEW      |                              |    CONTROLLER   |   |
|                 | <-----------------+ |                 | <--------------------------+ |                 |   |
+-----------------+                  |  +-----------------+                              +-----------------+   |
                    Information is   |                       The Controller sometimes                          |
                    presented to     |     ^                 updates the View directly                  +      |
                    the User via     |     |                                                            |      |
                    the User         |     |                                             [MANIPULATES   |      |
                    Interface (View) |     |                                              MODELS]       |      |
                      [RESPONSES]    |     | [UPDATES VIEW]                              The Controller |      |
                                     |     | When the                                    responds to    |      |
                                     |     | Models in the +---------------------------+ the user       |      |
                                     |     | Database      |                           | request by     |      |
                                     |     | change, the   |     DATA ACCESS LAYER     | operating on   |      |
                                     |     | View gets     |                           | Model objects  |      |
                                     |     | auto-updated  |     +---------------+     | in the Database|      |
                                     |     +-------------+ |     | MODEL OBJECTS |     | <--------------+      |
                                     |                     |     |    (IN THE    |     |                       |
                                     |                     |     |   DATABASE)   |     |                       |
                                     |                     |     +---------------+     |                       |
                                     |                     +---------------------------+                       |
                                     |                                                                         |
                                     +-------------------------------------------------------------------------+


I'm going to explain these layers plus a fourth layer, ViewModel, that is often used in
ASP.NET Core projects. Note that the explanation below is tailored to ASP.NET Core; other
MVC frameworks may be different.


1. Model: The model layer is probably the simplest layer in MVC. The model represents the
   data, but does nothing else. The model is independent of the View and the Controller,
   i.e. specific output representations and or programmed responses to user requests.
   When it comes to models, there is distinction to be made between Model classes and
   Model objects. Be aware of the difference between the two terms. Model classes are 
   templates for Model objects. Model objects contain most of the business-related data 
   in an MVC application. Model classes and Model object live separately; Model classes 
   are defined in the Models folder of the Common project, whereas Model objects live in 
   a Data Store such as a Database or File system. 

   Model classes are Plain Old Class Objects (POCO) that define important business entities 
   for your application. A model class represents the knowledge that the application needs 
   to know about a certain business entity. Therefore, a Model class needs to be designed 
   to capture information important to each entity. When designing a model class, it's 
   important to be selective about the information you capture.
   
   In a Calendar program, things like the Day, Alarms, Contacts etc. would be the Business 
   entities. To a Day class, things like Date, Day of the Week, Scheduled events etc., 
   would qualify as important information. So, these things will be represented as class 
   properties. What kind of information should be left out? Here's a rather extreme 
   example: you probably won't need a property that captures how many days have passed 
   since the death of Julius Caesar. It would not make much sense in a Calendar app as 
   your users probably don't care about this piece of information.
   
   In a model class, you can choose to add Data Annotations to each property to place 
   limitations on the values accepted by a property. For example, you can use C#'s 
   [PhoneNumber] annotation to ensure that all values for the PhoneNumber property follow 
   the standard. All model objects instantiated from this class have restrictions on the 
   value for the phone number: it is limited a certain length, and allows only integers, 
   brackets and dashes.
   
   Model classes do very little besides serve as a template for business entities. When
   the Controller layer, is instructed by a user or its internal logic to create business 
   entities, it will use the pre-defined Model classes as templates for these objects. 
   
   Once these model objects have been created, they are passed back and forth between the 
   Views, Controllers and Database. Therefore, Model objects are the drops of water in a 
   river of data that flows throughout the application. To display information to the user, 
   the Controller will send model objects to the View layer. To persistently store data, 
   the Controller will send model objects to the program's database/file system. Model 
   objects will live there, and when needed, the Controller layer will consult or modify them.
   
   The Common library contains the Model classes for HRSP.
   

2. View: "A view is a (visual) representation of its model. It would ordinarily highlight
   certain attributes of the model and suppress others. It is thus acting as a presentation
   filter."[5] 
   
   The View layer is the presentation layer; it controls how data from model objects are
   formatted and presented to the user. The View provides a variety of ways to present data 
   it receives from Model objects, subject to user direction. With information it receives 
   from the View, the user use the UI (the View) to issue orders to the program. The View 
   can be an HTML webpage, a GUI, a text-based UI, Razor Views etc.

   HRSP does not use standard ASP.NET Core Views due to the fact that it uses the Console
   to display text-based information to the user instead of HTML-based web pages. 
   Hotel-Client contains the View layer of this application.


3. ViewModel: This layer, strictly speaking, is not a part of MVC. It belongs to a variant 
   of MVC, the Model-View-ViewModel (MVVM) pattern. However, as MVC/MVVM is not an 
   either/or choice[6], I'm introducing this concept here. In MVVM, ViewModels take up the 
   role of Controllers, but do not necessarily replace them completely. See the sixth 
   source for more details. Here is an explanation of what ViewModels do from an MSDN 
   article[7]:
   

       The ViewModel class, which is the bridge between the view and the model. Each View
       class has a corresponding ViewModel class. The ViewModel retrieves data from the 
       Model and manipulates it into the format required by the View. It notifies the View 
       if the underlying data in the model is changed, and it updates the data in the Model 
       in response to UI events from the View.

       
   However, in ASP.NET Core, viewmodels appear to be passive containers. There are two 
   ways to send information to the user in an ASP.NET Core MVC application: have the 
   Controller send Models directly to the View, which displays it to the user OR the have 
   Controller load into the Viewmodel only the parts of the Model that the View requires, 
   and then send that to the View. 
   
   Though the first method is easier, in ASP.NET Core MVC, it is a best practice to use 
   viewmodels as intermediaries between models and views. There are two reasons for this: 
   The View() method can usually accept only a single model or Viewmodel object and 
   secondly, Viewmodels let you tailor models so that only required model data gets sent 
   to the View. For these reasons, only necessary Models are packed as properties into a
   Viewmodel, which is then sent to the View(). You should use a Viewmodel even if you 
   need to send only a single model to the View(), as this is something that could change 
   in the future. For more information, see the project 'ASPNETCore WebApp 1A - Routing'.

   HRSP does not use any Viewmodels.


4. Controller: The controller layer is the brain of the application. It consists of 
   controller class(es) whose methods respond to incoming requests. Also, the business 
   rules and the business logic of the application are sometimes defined and applied in 
   controller class methods. 
   
   When a user makes a request via the View, it gets passed to a controller whose 
   method is designated to respond to that particular request. Controllers will process, 
   interpret and validate incoming requests. In ASP.NET Core, Controllers do much of the 
   in-program communication and handling of data by doing things like routing, 
   authentication, authorization, request validation and redirection, response handling, 
   model formatting and generation etc.  Once that is done, it is their job to query and 
   modify model objects in the database and create or update Views to fulfill the user 
   request. By doing these things, this layer controls and directs application flow.

   To compare the Controller layer to Multitier Architecture's layers for a moment, the 
   Controller layer seems to combine Multitier's Business Logic and Data Access Layers.
   That might be a okay for small applications, but for mid-to-large sized applications, 
   combining two layers like that will lead to confusion and complexity. For more complex
   programs, you'll want to keep your Controllers rather lean and move your business logic
   into a separate software component, such as the Model layer. 


PROS AND CONS OF THE MVC PATTERN

This list is taken from Pg 194-195 of 'Pattern-Oriented Software Architecture For 
Dummies'[1]:


    Benefits

    The flexibility of decoupling the data (model) from the output (view) and input 
    (controller) is the primary benefit of the MVC architecture. You’ll see this over 
    and over again in the following list of benefits:

    ✓ The model is strictly separated from the UI components in this architecture. You 
      can use the same data to supply multiple views.

    ✓ Changes to the data in the underlying model are reflected in all the views 
      automatically. This is possible because there is a single source of the data being 
      displayed.

    ✓ You can change the view and controller elements of the system without changing the 
      data model. This capability increases the flexibility of the system. You can keep the 
      underlying model element consistent and intact, and exchange the view and controller 
      components of the system.

    ✓ Because the UI code is independent of the model, when you need to make major changes 
      in the UI section, the underlying data doesn’t need to change. This kind of major 
      change can result from moving the system to new hardware or to hardware that has a 
      different look and feel.

    ✓ The views don’t interact. As a result, you can change an individual view without 
      having to make changes in the other views.

    ✓ MVC architectures can be used as frameworks to be used and extended in other 
      situations. The three components are related yet independent, which simplifies 
      maintenance and evolution.

    Liabilities

    In addition to the benefits, liabilities come along with using MVC. You must balance 
    these liabilities with the benefits when you design your system:

    ✓ Complexity is increased by separating the three components of MVC. You have more 
      components to build and maintain than you would if you’d designed the system as a 
      monolith. Unless you need flexibility in the UI or the views, MVC may add more 
      overhead than your application really needs.

    ✓ Changes to the model are published to all the views that subscribed for them. The 
      number of recipients of change-notification messages increases as the system gets 
      bigger. To overcome this liability, consider the big picture when you design the 
      scope of changes that result in update publications...

    ✓ The controller and the views grow closer with time. Even though the components are 
      individuals, they have strong relationships that limit your ability to reuse one 
      component without the others. As the system grows and evolves, views will be added 
      to the system, along with resulting enhancements to the controller that allow the 
      views to be selected and controlled. Because the components are so intertwined, 
      reusing only the controller or only the views is more difficult than reusing the
      controller and views together. The relationship also limits your ability to insert
      new versions of either component, because the new version must be adapted to support 
      the component that isn’t being replaced.

    ✓ The controller and view components know quite a lot about the model. Changes in the
      model may require changes in both of the other two components. Adding indirection 
      helps mitigate this liability, however, as I discuss in the implementation section 
      (“Step 4: Design and build the controllers”) later in this chapter.

    ✓ Inefficient data access can result because of the separation of views and model data 
      and the need to go through the model’s API. This problem is especially apparent if the 
      view must request unchanged data from the model frequently. You can improve 
      responsiveness, however, by designing the view to cache data.

    ✓ Both controller and view components require changes when they’re ported to a new 
      system. These components contain some platformdependent code, so when the components 
      are ported to a new system, the platform-dependent code requires changes.



BREAKDOWN OF MULTITIER ARCHITECTURES


In a a 2-tier application, the program is usually separated into two halves:
a client and a server. These programs run on two separate machines:


+------------------------------------------------+ +-----------------------------------------+
|                CLIENT APPLICATION              | |          SERVER-SIDE APPLICATION        |
|                                                | |                                         |
| +--------------------------------------------+ | | +---------------------+                 |
| |                   LAYER 1                  | | | |  DATA ACCESS LAYER  |  +------------+ |
| |                                            | | | |                     |  |            | |
| | +----------------+      +----------------+ | | | |  +---------------+  |  |            | |
| | |  PRESENTATION  | +--> |    BUSINESS    | +------> |  DATA ACCESS  | +-> |  DATABASE  | |
| | |     LOGIC      | <--+ |     LOGIC      | <------+ |     LOGIC     | <-+ |            | |
| | +----------------+      +----------------+ | | | |  +---------------+  |  |            | |
| |                                            | | | |                     |  +------------+ |
| +--------------------------------------------+ | | +---------------------+                 |
+------------------------------------------------+ +-----------------------------------------+

        RUNS ON USER'S PC OR WEB SERVER                RUNS ON APPLICATION/DATABASE SERVER



+--------------------+  +-------------------------------------------+  +----------------------+
| CLIENT APPLICATION |  |             APP SERVER/API                |  | DATABASE APPLICATION |
|                    |  |                                           |  |                      |
|  +--------------+  |  |  +--------------+        +-------------+  |  |    +------------+    |
|  |              |  |  |  |              |        |             |  |  |    |            |    |
|  | PRESENTATION |  |  |  |   BUSINESS   |        | DATA ACCESS |  |  |    |            |    |
|  |    LAYER     |  |  |  |    LAYER     |        |    LAYER    |  |  |    |            |    |
|  |              | +----> |              | +----> |             | +------> |            |    |
|  |  containing  |  |  |  |  containing  |        | containing  |  |  |    |  DATABASE  |    |
|  |              |  |  |  |              |        |             |  |  |    |            |    |
|  | PRESENTATION | <----+ |   BUSINESS   | <----+ | DATA ACCESS | <------+ |            |    |
|  |    LOGIC     |  |  |  |    LOGIC     |        |    LOGIC    |  |  |    |            |    |
|  |              |  |  |  |              |        |   (+ ORM)   |  |  |    |            |    |
|  +--------------+  |  |  +--------------+        +-------------+  |  |    +------------+    |
|                    |  |                                           |  |                      |
+--------------------+  +-------------------------------------------+  +----------------------+

  RUNS ON USER'S PC              RUNS ON AN APPLICATION SERVER           RUNS ON A DATABASE
    OR WEB SERVER                                                              SERVER




ARCHITECTURE OF THE HOTEL-SERVER PROJECT

This project pairs the ideas of tiers from the Multitier Architecture with layers from the
MVC architectural pattern. This is not unusual, as N-Tier Architecture is often used in 
conjunction with the MVC pattern for client-server applications.

This project, Hotel Reservation System Project (HRSP), is divided into 2 tiers and a 
library component:


    1. Hotel-Client,            (Client Frontend)
    2. Hotel-Server, and        (Application Server)
    3. Common                   (Shared Library)


Hotel-Client is the client program, Hotel-Server is the Application Server and Common is a 
library that stores files shared by these two programs. A copy of Common will be shipped 
with all copies of Hotel-Client and Hotel-Server.

Here is a diagram that portrays HRSP's structure: 


                                   RUNS ON USER'S PC

                                +---------------------+
                                | CLIENT APPLICATION  |
                                |                     |
                                |  +---------------+  |
                                |  |    COMMON     |  |
                                |  |               |  |
                                |  | Model Classes |  |
                                |  +---------------+  |
                                |                     |
                                |       ^    +        |
                                |       |    |        |
                                |       +    v        |
                                |                     |
                                |  +---------------+  |
                                |  | HOTEL-CLIENT  |  |
                                |  |               |  |
                                |  |  View Layer   |  |
                                |  +---------------+  |
                                |                     |
                                |       +    ^        |
                                +---------------------+
                                        |    |
                                        |    |
                                        |    |
                                +-------------------------------------------+
                                |       v    +                              |
                                |                                           |
                                |  +---------------+     +---------------+  |
                                |  | HOTEL-SERVER  | +-> |    COMMON     |  |
                                |  |               |     |               |  |
                                |  |  Controllers  | <-+ | Model Classes |  |
                                |  +---------------+     +---------------+  |
                                |                                           |
                                |       +    ^                              |
                                |       |    |                              |
                                |       v    +             APP SERVER       |
                                |                           PROGRAM         |
                                |  +---------------+                        |
                                |  |   DATABASE    |                        |
                                |  |               |                        |
                                |  | Model Objects |                        |
                                |  +---------------+                        |
                                |                                           |
                                +-------------------------------------------+

                                         RUNS ON APPLICATION SERVER


Let's take a look at the structure of this project:

TIERS

1. Presentation Tier

In HRSP, the frontend role falls to Hotel-Client, which is a program that let the user 
communicate to HRSP application. Users will issue orders and make requests of HRSP through 
Hotel-Client, which will pass them on to the heart of the application, the Hotel-Server 
program. If HRSP were deployed in the real world, many copies of Hotel-Client would run on
desktop and laptop computers that serve Hotel front desk clerks and their managers. 
Therefore, the presentation tier for Hotel-Client is intended to be PCs.

2. API/App Server

In HRSP, Hotel-Server is the Application Server. The Business Logic Tier's hardware platform 
is usually a physical (or virtual) SERVER. App Server programs run on these servers, 
listening for communications from the frontend. Client frontends pass User requests over 
the internet to the App Server program to do the processing.

3. Data Tier

For this project, Hotel-Server also contains the Data Access Tier. 


LAYERS

This project uses a modified MVC pattern to structure the layers of the application. More
specifically, it uses Models and Controllers but does away with traditional Views. Instead
of HTML/CSS/Javascript Views, HRSP deploys a console application to the user's PC. Here 
are the three layers in HRSP:

1. Models

Model classes are contained in the library called Common. It will be compiled down to a 
library which will be shipped with both Hotel-Client and Hotel-Server. Model objects will 
be stored in a PostgreSQL database. 


2. Views

This layer is contained in Hotel-Client. It authenticates users, accepts user input, 
validates it and passes it on to Hotel-Server for processing. 

3. Controllers

The Controller layer can be found in Hotel-Server. It does both business logic and 


This layer and the Data Access Layer is part of Hotel-Server. The BLL recieves requests 
from the presentation layer and responds to user input by doing all the processing needed 
to fulfill their requests. It makes calls to the Data Access Layer if it needs to make
changes to persistent data. 

3. Data Access Layer

The DAL contains the Database and code that 



SOURCES

1: https://en.wikipedia.org/wiki/Distributed_computing
2: https://en.wikipedia.org/wiki/Client%E2%80%93server_model