1. SETTING UP THE DATABASE FOR THE HOTEL RESERVATION SYSTEM PROJECT

This program will store data in a PostgreSQL database and it will use Entity Framework 
Core (EFC) as the ORM. The sections below discuss concepts and frameworks that concern 
setting up HRSP to connect and talk to a database. 


2. INTRODUCTION TO DATABASE CONCEPTS AND TERMS

2.1 WHAT IS A DATABASE?

A database is an software system that stores data. A snippet I found on the internet 
describes databases like this: "A database is a computerised system that makes it easy to 
search, select and store information." Databases are used in institutions and businesses 
to store organizational data like customer records and profiles, sales transactions, 
product information etc. Computers, web browsers and phones have many built-in databases
for tracking information. However, storing data is not worthwhile unless the database is 
secure and well-organized, yet easily accessible to those who have authorization.

This is why a database program is rarely marketed as a standalone piece of software; 
instead most databases come with an ecosystem of additional tools. This collection of 
database and tooling is called a Database Management System (DBMS). A DBMS comes with 
tools to facilitate things like security rules and user access management, user 
authentication, search optimization, data management (Data integrity, encryption, 
compression, de-duplication, backup and recovery etc.), report generation etc. 

In 'Databases: A Beginner's Guide', Andy Oppel provides some definitions for terms 
related to databases[]:
 
 
    1. Database Object (Page 4): "A database object is a named data structure that is 
       stored in a database. The specific types of database objects supported in a 
       database vary from vendor to vendor and from one database model to another."
       
    2. Database Model (Page 4): "Database model refers to the way in which a database 
       organizes its data to pattern the real world." 
       
       Historical database models include Flat File, Hierarchical, Network and the 
       Inverted file model. Some modern niche database models: Object-oriented, 
       Object-Relational, Graph, Document-oriented, and NewSQL.
    
       The most common modern database models are Relational and NoSQL.
    
    3. File (Page 4): A file is a collection of related records that are stored as a 
       single unit by an operating system. Given the unfortunately similar definitions of 
       files and databases, how can we make a distinction?… The answer lies in an 
       understanding of certain characteristics or properties that databases possess 
       which are not found in ordinary files, including the following:
    
           * Management by a database management system (DBMS)
           * Layers of data abstraction
           * Physical data independence
           * Logical data independence
    
    4. Database Management System (DBMS) (Page 5): The database management system (DBMS) 
       is software provided by the database vendor. Software products such as Microsoft 
       Access, Oracle, Microsoft SQL Server, Sybase ASE,DB2, Ingres, and MySQL are all 
       DBMSs…
    
       The DBMS provides all the basic services required to organize and maintain the 
       database, including the following:
    
       * Moves data to and from the physical data files as needed.
       * Manages concurrent data access by multiple users, including provisions to prevent 
         simultaneous updates from conflicting with one another.
       * Manages transactions so that each transaction’s database changes are an 
         all-or-nothing unit of work. In other words, if the transaction succeeds, all 
         database changes made by it are recorded in the database; if the transaction 
         fails, none of the changes it made are recorded in the database.
       * Supports a query language, which is a system of commands that a database user 
         employs to retrieve data from the database.
       * Provides provisions for backing up the database and recovering from failures.
       * Provides security mechanisms to prevent unauthorized data access and modification.


2.2 RELATIONAL DATABASE MANAGEMENT SYSTEMS (RDBMS)

Andy Oppel explains the Relational Model on pages 17-19[]:


    In addition to complexity, the network and hierarchical database models share another 
    common problem—they are inflexible. You must follow the preconceived paths through 
    the data to process the data efficiently. Ad hoc queries, such as finding all the 
    orders shipped in a particular month, require scanning the entire database to locate 
    them all. Computer scientists were still looking for a better way…
    
    The relational model is based on the notion that any preconceived path through a 
    data structure is too restrictive a solution, especially in light of ever-increasing 
    demands to support ad hoc requests for information. Database users simply cannot 
    think of every possible use of the data before the database is created; therefore, 
    imposing predefined paths through the data merely creates a “data jail.” The 
    relational model allows users to relate records as needed rather than as predefined 
    when the records are first stored in the database. Moreover, the relational model 
    is constructed such that queries work with sets of data (for example, all the 
    customers who have an outstanding balance) rather than one record at a time, as 
    with the network and hierarchical models.
    
    The relational model presents data in familiar two-dimensional tables, much like 
    a spreadsheet does. Unlike a spreadsheet, the data is not necessarily stored in 
    tabular form and the model also permits combining (joining in relational terminology) 
    tables to form views, which are also presented as two-dimensional tables. In short, 
    it follows the ANSI/SPARC model and therefore provides healthy doses of physical and 
    logical data independence. Instead of linking related records together with physical 
    address pointers, as is done in the hierarchical and network models, a common data 
    item is stored in each table, just as was done in flat file systems…
    
    The elegant simplicity of the relational model and the ease with which people can 
    learn and understand it has been the main factor in its universal acceptance. The 
    relational model is the main focus of this book because it is ubiquitous in today’s 
    information technology systems and will likely remain so for many years to come.


In the Relational Model, two pieces of data are linked to each other with respect to the 
relationship they have to another. A table is a physical representation of a relation.

This article will only consider the most common kind of databases, the Relational 
Database Management System. Here is an explanation of RDBMSes[]: 
Source: from db-engines.com


    1. Relational Databases: Relational database management systems (RDBMS) support the 
       relational (=table-oriented) data model. The schema of a table (=relation schema) 
       is defined by the table name and a fixed number of attributes with fixed data 
       types. A record (=entity) corresponds to a row in the table and consists of the 
       values of each attribute. A relation thus consists of a set of uniform records.
    
       The table schemas are generated by normalization in the process of data modeling.
    
       Certain basic operations are defined on the relations:
    
       * classical set operations (union, intersection and difference)
       * Selection (selection of a subset of records according to certain filter criteria 
         for the attribute values)
       * Projection (selecting a subset of attributes / columns of the table)
       * Join: special conjunction of multiple tables as a combination of the Cartesian 
         product with selection and projection.
         
      These basic operations, as well as operations for creation, modification and 
      deletion of table schemas, operations for controlling transactions and user 
      management are performed by means of database languages​​, with SQL being a well 
      established standard for such languages.
    
      The first relational database management systems appeared on the market at the 
      beginning of the 1980s and since have been the most commonly used DBMS type.
    
      Over the years, many RDBMS have been expanded with non-relational concepts such as 
      user-defined data types, not atomic attributes, inheritance and hierarchies, which 
      is why they are sometimes referred to as object-relational DBMS.
      
      
Here is a list of well known RDBMSes:


    Oracle
    MySQL
    Microsoft SQL Server
    PostgreSQL
    DB2
    Microsoft Access
    SQLite
    Teradata
    MariaDB


The most popular open source databases as of October 2018 are: PostgreSQL and SQLite. 
Both are robust and capable. 

SQLite is designed to be a light-weight, server-less single file database. It's used in 
electronic devices like phones, PDAs, MP3 players as well as web browsers. If you need a
low footprint, high-quality database, go with SQLite.

PostgreSQL is a open source, fully featured RDBMS. It's more powerful than MySQL/MariDB,
but it has better data integrity. It will serve well as the database for web applications
and for other kinds of heavier duty software.   
 
 
2.3 OTHER DATABASE TERMS TO LEARN BEFORE PROCEEDING

There is much more to learn about databases before proceeding to Section 3. Here are 
lists of such things, mostly taken from Caleb Curry's website.[]


SQL

You should know the basics of SQL, because this is the language of databases.
 

DATA

    * Data
    * Database
    * Relational Database
    * Database Management System
    * Relational Database Management System
    * Null
    * Anomalies
    * Referential Integrity 


DATABASE COMPONENTS

    * Entity
    * Attribute
    * Relation
    * Tuple
    * Table
    * Row
    * Column
    * File
    * Record
    * Field
    * Value
    * Entry
    * Database Design
    * Schema
    * Normalize
    * Naming Conventions
    * Keys
    

CONCEPTUAL DATABASE DESIGN CONCEPTS

Andy Oppel explains on page 30: []

    … involves studying and modeling the data in a technology-independent manner. The 
    conceptual data model that results can be theoretically implemented on any database 
    or even on a flat file system. The person who performs conceptual database design 
    is often called a data modeler.


    * Entity vs. Entity-Type
    * External Entities
    * Attributes
    * Relationships
    * One-to-One Relationships
    * One-to-Many Relationships
    * Many-to-Many Relationship
    * Recursive Relationships 
    * Business Rules
    
    
LOGICAL & PHYSICAL DESIGN CONCEPTS

Andy Oppel explains on page 30: []

Logical Database Design


    …is the process of translating, or mapping, the conceptual design into a logical 
    design that fits the chosen database model (relational, object-oriented, 
    object-relational, and so on). A specialist who performs logical database design is 
    called a database designer, but often the database administrator (DBA) performs all 
    or part of this design step.


Physical Database Design

    The final design step is physical database design, which involves mapping the logical 
    design to one or more physical designs, each tailored to the particular DBMS that 
    will manage the database and the particular computer system on which the database 
    will run. The person who performs physical database design is usually the DBA.


    * Tables
    * Columns and Data Types
    * Constraints
    * Primary Key Constraints
    * Primary Key Constraints
    * Intersection Tables
    * Intersection Tables
    * NOT NULL Constraints
    * CHECK Constraints
    * Constraint Enforcement Using Triggers
    * View


ENTITY-RELATIONSHIP MODEL

In the context of a database, an entity–relationship model (ER model for short) 
describes relationships between instances of entities.


    * Keys (Primary, Foreign, Compound, Alternate etc.)
    

2.1 ENTITY FRAMEWORK CORE

When you start up a program that uses a database, as this one does, one of the first things the
program will do is try and talk to the database. A database usually understands only the the SQL 
language. When you connect a database to a program written in C# or another general purpose 
programming language, you need an translator program to translate SQL to C# and vice versa. A 
program that translates SQL to a general purpose programming language like Java, C# or JavaScript 
and vice versa is called an  OBJECT-RELATIONAL MAPPER (ORM).


                                          +---------+
                                          |         |
                                          | PROGRAM |
                                          |         |
                                          +----+----+
                                               ^
                                               |
                                               v
                                         +-----+-----+
                                         |           |
                                         | ENTITY    |
                                         | FRAMEWORK |
                                         | CORE      |
                                         |           |
                                         +-----+-----+
                                               ^
                                               |
                                               v
                                         +------------+
                                         |            |
                                         |  DATABASE  |
                                         |            |
                                         +------------+


Entity Framework Core (from here on in referred to as EFC or EF Core) is an ORM that sits between 
a program like Hotel-Server and its database. When you hook it up to a data source, such as a 
database, an ORM reads in raw data and turns it into collections of C# objects for use in the 
program. By doing this, EF Core is translating data as it is represented in the database into a 
data representation that C# programs would understand.

Entity Framework Core is the standard ORM solution in the .NET world, provided by Microsoft for 
.NET Core projects. You'll need several nuget packages to get EF Core functionality: 

    Microsoft.EntityFrameworkCore, 
    Microsoft.EntityFrameworkCore.Relational, and 
    Microsoft.EntityFrameworkCore.Tools (For Migrations. Tools for Package Manager Console.)
    
Fortunately, all these packages come with the Microsoft.AspNetCore.All metapackage, which appears 
to be mandatory for all ASP.NET Core projects. If you want to use the command line interface
while working with migrations, you will this package, which must be installed separately:

    Microsoft.EntityFrameworkCore.Tools.DotNet (For Migrations. Tools for the Command-line 
                                                Interface. )

Note: The docs say that "You have to install this package by editing the .csproj file; you can't 
use the install-package command or the package manager GUI."



2.2 HOW DOES ENTITY FRAMEWORK CORE TRANSLATE INFORMATION TO AND FROM THE DATABASE?

Consider this table from a database, called Contacts:

+----+-----------+----------+----------------+
| Id | FirstName | LastName |  PhoneNumber   |
+----+-----------+----------+----------------+
|  1 | Bonnie    | Tsing    | (123) 456-7890 |
|  2 | Barry     | Forg     | (198) 928-9834 |
|  3 | Linda     | Blom     | (234) 239-9231 |
+----+-----------+----------+----------------+

The table contains 3 records. Each record has 4 fields. Each record contains Contact information 
for one person. This is how data is stored and represented in a database. 

There are other ways to represent this data. Take a look at the C# model class below: 

    public class Contact
    {
        [Required]
        public int Id { get; set; }
        
        [MinLength(2)] 
        [MaxLength(50)]
        public string FirstName { get; set; }
        
        [MinLength(2), MaxLength(50)]
        public string LastName { get; set; }

        [Phone]
        public string PhoneNumber { get; set; }
    }
    
The Contact class has a name similar to the table and it has four properties, but what is most 
interesting is the property names - Id, FirstName, LastName and PhoneNumber - are the same as the 
column names in the Contacts table above. Do you see where this is going?

Put simply, records in a database can be converted into C# objects. The structure of a table in 
a database, such as the Contacts table above, can be represented in a C# program in the form a 
plain C# POCO model class. Columns in a table can be mapped to properties in the class. The 
information in a record from the Contacts table can be represented in the form of a Contact 
object. To say it again, data contained in a record from a database table can transmuted into a 
form recognizable and usable in a C# program - a C# object.  

This is Entity Framework Core's job: to map records from tables in a database to a collection of C# 
objects and and the reverse. More specifically, EF Core acts as a translation layer between the 
Hotel Reservation project and its database, translating C# code into SQL commands and C# objects 
into records in the database and vice versa, all without writing SQL.

EF Core needs several things to set up the program to interface with a database. There are the 
concepts you need to understand:


     1) Database Provider,          (Defined in DbContextFactory/MyDbContextFactory.cs)
     2) Data Model,                 (Defined in the Models folder of the Common project)
     3) Database Schema,            (Defined in DbContext/Context.cs)
     4) Migrations                  (Generated into the Migrations Folder)


The next three sections explain these concepts.



2.3 DATABASE PROVIDERS
 
A Database Provider is a "a software library consisting of classes that provide data access 
services such as connecting to a data source, executing commands at a data source and fetching 
data from a data source with support to execute commands within transactions. It resides as a 
lightweight layer between data source and code, providing data access services with increased 
performance." (Source: https://www.techopedia.com/definition/25227/net-data-provider). 

A DATABASE PROVIDER is a small library that helps EF Core to talk to databases from a certain 
vendor. For instance, there are Database Providers for SQL Server, SQLite, PostgreSQL and other 
databases. EF Core can talk to any database if it has the database provider library for it. When 
Hotel-Server is run, Entity Framework will be brought online to talk to the database. The first 
thing EFC will do is search for the Database Provider. 

Therefore, you need to find the right database provider for the database in your project and add
it to the program via a Nuget package. The Database Provider for this project is the 
'Npgsql.EntityFrameworkCore.PostgreSQL' package. By using this package, EF Core will come to 
determine that this project uses a PostgreSQL database. Through it, EFC can interface with the 
database and carry out operations on it. 

Once it can talk to the database, EF Core will will use the Data Model to transform a SQL query 
into an object model representation of a query (which is called a canonical command tree) and vice 
versa. .NET Database Providers can consume canonical command trees to talk the database.


Location: DbContextFactory/MyDbContextFactory.cs, OR
          ConfigureServices() method of Startup.cs 
to configure the database provider, connection string and other related things.

To learn more about database providers, go to: https://docs.microsoft.com/en-us/ef/core/providers/



2.4 DATABASE DATA MODEL vs. DATABASE SCHEMA

Once EF Core confirms that it can talk to the database via the database provider, it needs 
the Data Model and Schema of the database. Why? In order to do two-way translations i.e. to map
tables and other databases entities to C# objects and vice versa, EF Core must know the names 
and properties of entities in the database and their relationships.
 
The Data Model is distinct from a Database Schema; see this StackOverflow Answer from richik 
jaiswal to learn distinction[1]:

     A schema is a blueprint of the database which specifies what fields will be present and 
     what their types will be. For example an employee table will have an employee_ID column 
     represented by a string of 10 digits and an employee_Name column with a string of 45 
     characters.
     
     Data model is a high level design implementation which decides what can be present in the 
     schema. It provides a database user with a conceptual framework in which we specify the 
     database requirements of the database user and the structure of the database to fulfill 
     these requirements.
     
     A data model can, for example, be a relational model where the data will be organised in 
     tables whereas the schema for this model would be the set of attributes and their 
     corresponding domains.

A Data Model is an abstract formalization of a database's entities. The basic properties of database 
entities like tables and columns are defined in model classes, forming the DATA MODEL. These 
classes are most usually found in the 'Models' or 'Entities' folder of most ASP.NET Core projects. 

For an example, let's take another look at the Contact class from earlier:


    public class Contact
    {
        [Required]
        public int Id { get; set; }
        
        [MinLength(2)] 
        [MaxLength(50)]
        public string FirstName { get; set; }
        
        [MinLength(2), MaxLength(50)]
        public string LastName { get; set; }

        [Phone]
        public string PhoneNumber { get; set; }
    }


This class will serve as a blueprint for Contact objects, which represent records in a Contacts
table. Note that the properties have data annotation attributes on them. These annotations mandate
values for Id property and establish value minimums and maximums on FirstName and LastName 
properties; as the data model informs the schema, when the schema is written, these restrictions 
will carry over to it. 

Location: /Common/Models/Tables. Go here to see the model classes for this project.

Let's move on to discussing the schema. The DATABASE SCHEMA is a more specific definition of a 
database's entities and their. It serves as a snapshot of the database's topology at a certain 
point in time, usually reflecting its current state. The schema takes entities defined in the 
data model, plus any data annotation attributes defined therein, and adds other things to it. This 
may include restrictions on character length for a field, marking certain fields as mandatory 
when a record is created, and establishing the nature of relationships between entities.   

First, take a look at the Hotel model class (from the Models folder): 


    public class Hotel : IObjectWithState
    {
        // The primary key of the Hotel table in the Database is the Room Number.
        [Key]
        public long Id { get; set; } 
        public string Name { get; set; }
        public string Address { get; set; }
        public string PhoneNumber { get; set; }

        // Hotel Objects have a HotelRooms property to track the list of hotelrooms at a hotel
        // without needing to query the database.
        public virtual IEnumerable<HotelRoom> HotelRooms { get; set; }


        // ORMs (Object-Relational Mapper) map properties in an object to a table. The ObjectState
        // property is not a table column; it is used to track changes in an entity. This will 
        // likely happen in the endpoints of this project.
        [NotMapped]
        public ObjectState State { get; set; }
    }

There are schemas for at least three levels of a database: physical schema (how data blocks are
stored at the lowest level; this is where database designers work), logical schema (how records
get stored in data structures; this level is where programmers and DB administrators work) and
view schemas (which are schemas for end-user interaction). 

Taken from Context.cs, here is the corresponding Schema for a Hotel table:


    public class Context : DbContext
    {
        public virtual DbSet<Hotel> Hotels { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Hotel>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Id).IsRequired().ValueGeneratedOnAdd();
                entity.Property(e => e.Name).IsRequired().HasMaxLength(100);
                entity.Property(e => e.Address).IsRequired().HasMaxLength(200);
                entity.Property(e => e.PhoneNumber).IsRequired().HasMaxLength(100);
            });
        }
    }
        

When any ASP.NET Core program runs normally, EF Core will be sitting between the program and its
database, translating SQL and database records into C# commands and objects. Provided it has the 
data model and the schema, EF Core has a map to the layout of any particular database.

Let's talk about the schema for the Hotel table; EF Core is going to use it to translate entities 
from the database into C# objects. When EF Core converts information from a data source into C# 
objects it needs two things: a pre-defined model class that can represent data from each table 
and a collection to hold these model objects. 

Let's talk about the Hotels DbSet<Hotel> data structure first. The first thing that is declared in 
the Context class is a data structure to hold objects as they get converted from records, called 
Hotels. DbSet<Hotel> is a generic data structure that can contain only Hotel objects. This is due
to the fact that Hotel is the model class for the Hotels table. 

The purpose of a Schema is to define the specific shape and form of the entities in a table.
Following the declaration of Hotels DbSet, comes the OnModelCreating() method. This method is 
overridden and the schema is defined within; it lays out primary keys for tables and Navigation 
properties (foreign keys) between entities. Lastly, we can also define field constraints in this 
method, which are specifications and limitatations for every column in the Hotel Table. For 
instance, HasKey() denotes the Id field as the Primary Key of a table. The other properties are 
efined with the Property() method. The Id, Name, Address and PhoneNumber fields are marked as 
required fields. The character lengths of each field are also specified. 

As EF Core converts every record into a new object in a DbSet<T> collection, it makes sure that all 
these requirements are met. The fields of each record in the table are copied and assigned to the 
properties of a new C# object. Once a new Hotel object is populated with data from a record, it 
gets stored in the Hotels collection.
 


2.5 MIGRATIONS

I'll touch on migrations lightly, but there is another file that deals with this subject in full. 

During the course of developing a database, you will add and remove tables and other entities 
from it. The relationships between entities may also change. In other words, during the lifetime
of a database, its topology is in constant flux. A schema can contain only a snapshot of the 
topology of a database. 

To ensure data integrity, it is a best practice to take a snapshot of a database's topology every
time a change is made to the schema. Schema snapshots are called MIGRATIONS; migrations serve as 
version control for a database's schema. You can use migrations to update to or rollback from a 
version of the database. 

If a database already exists, you can import it into an ASP.NET Core project and 
generate a schema from the database. For new databases, the schema has to be written by the 
programmer.

Taken from the file called, '20180128032156_CreateHotelHotelRoomRoomTypeBedTypeRoomReservationTables.cs',
this is the Logical schema for the Hotel table: 


    public partial class CreateHotelHotelRoomRoomTypeBedTypeRoomReservationTables : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Hotels",
                columns: table => new
                {
                    Id = table.Column<long>(type: "int8", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy",
                                     NpgsqlValueGenerationStrategy.SerialColumn),
                    Address = table.Column<string>(type: "varchar(200)",
                                                   maxLength: 200,
                                                   nullable: false),
                    Name = table.Column<string>(type: "varchar(100)",
                                                maxLength: 100,
                                                nullable: false),
                    PhoneNumber = table.Column<string>(type: "varchar(100)",
                                                       maxLength: 100,
                                                       nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Hotels", x => x.Id);
                });
        }
    }
    

Location: /Migrations/Migrations.txt. This file examines migrations in greater depth.



3. SETTING UP THE DATABASE

Now that the concepts have been introduced, this section will introduce classes where you have
to configure the database. Before you can do operations on the database, you must initiate a new 
session with the database. This will require several pieces of information that must be passed
to the database. 

The following sections mention some of them, but others may be required: 


3.1 CONNECTION STRING

What is a connection string?[2]:

"Most database providers require some form of connection string to connect to the database. 
Sometimes this connection string contains sensitive information that needs to be protected. You 
may also need to change the connection string as you move your application between environments, 
such as development, testing, and production." 

A connection string is database-related information that you must provide to start a session with
it. This might include: the hostname of the computer on which the database is running, the 
database's name, user authentication information and DB configuration data. 

See the second article in the sources section for more information. 
 

3.2 CONTEXT CLASS (aka DbContext class)

A Context class is an important EF Core class that represents a session with the database. According 
to 'Entity Framework Core: DbContext'[3], DbContext is the class where you can do all of these 
things:

    
   * Manage database connection
   * Configure model[s] & relationship[s]
   * Query database
   * Saving data to the database
   * Configure change tracking
   * Caching
   * Transaction management
   

Aside from representing a session with the database, a Context class also contains the SCHEMA for 
the database. This is why you need to create a Context class in your project.

There are two approaches you can take, contingent on whether you have an existing database. If you 
are starting a greenfield project WITHOUT an existing database, you go with the NEW DATABASE 
approach. If you have an existing database, and you want to write a program to talk to it, you use 
the EXISTING DATABASE approach.


    1. NEW DATABASE: Write your own Context class for your new database.
       (More details: https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/new-db)
       For full details, see this project: ASPNETCore WebApp 2A - Getting Started with a New Database
    2. EXISTING DATABASE: Generate a Context class from the database via the package manager command 
       line. (More details: https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db)
       For full details, see this project: ASPNETCore WebApp 2B - New Project With an Existing Database


Let's look at the NEW DATABASE approach: you have to create a Context class that inherits from 
Microsoft.EntityFrameworkCore.DbContext. It can be named Context, DbContext, HotelContext or 
something similar. Just append the word 'Context' to the filename. The Context class for this 
project can be found in the Context.cs file of the DbContext folder. 

Once you create a new Context class, you have to define the schema in it. This includes:

* Defining the program-side equaivalent of a table (by declaring a DbSet<T> collection)
* Defining relationships between entities (by declaring them in the OnModelCreating() method) 

Go to Context.cs to learn more about these things. 


3.3 INITIATING A NEW SESSION 

After creating the data model in the Context class, you need to configure a new session. To do 
this, you have to pass in the connection string to a Context object in a DbContextOptions object.

The Microsoft Docs article, "Configuring a DbContext"[4] gives information on how to configure 
the DbContextOptions class:


    DbContext must have an instance of DbContextOptions in order to perform any work. The 
    DbContextOptions instance carries configuration information such as:
    
    
        * The database provider to use, typically selected by invoking a method such as 
          UseSqlServer or UseSqlite
        * Any necessary connection string or identifier of the database instance, typically passed 
          as an argument to the provider selection method mentioned above
        * Any provider-level optional behavior selectors, typically also chained inside the call 
          to the provider selection method
        * Any general EF Core behavior selectors, typically chained after or before the provider 
          selector method
          
          
    The following example configures the DbContextOptions to use the SQL Server provider, a 
    connection contained in the connectionString variable, a provider-level command timeout, and 
    an EF Core behavior selector that makes all queries executed in the DbContext no-tracking by 
    default:
    
    
        optionsBuilder
            .UseSqlServer(connectionString, providerOptions=>providerOptions.CommandTimeout(60))
            .UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);


    The DbContextOptions can be supplied to the DbContext by overriding the OnConfiguring method 
    OR (emphasis mine) externally via a constructor argument. 
    
    If both are used, OnConfiguring is applied last and can overwrite options supplied to the 
    constructor argument.
    
    
There are three ways to configure the Context class, DbContextOptions and the Connection string
in preparation for a new session:

    1. Override the OnConfiguring() method (in DbContext/Context.cs)
    
    2. Structure Context class's constructor to accept an DbContextOptions object: This project
       uses this approach.
       
       Write a separate Context Factory class that inherits from IDesignTimeDbContextFactory<T> 
       Class. The Context Factory class will pass a DbContextOptions object to class Context, and 
       then instantiates a Context object.
       (see DbContextFactory/MyDbContextFactory.cs).
       
    3. Dependency Injection: This is done in the ConfigureServices() method of Startup.cs. From 
       this article[4]: "EF Core supports using DbContext with a dependency injection container. 
       Your DbContext type can be added to the service container by using the AddDbContext<TContext> 
       method.         
                                                                    
       AddDbContext<TContext> will make both your DbContext type, TContext, and the corresponding 
       DbContextOptions<TContext> available for injection from the service container."

See the fourth article for information more about these options. 


SOURCES

1: https://stackoverflow.com/questions/25093452/difference-between-data-model-and-database-schema-in-dbms
2: https://docs.microsoft.com/en-us/ef/core/miscellaneous/connection-strings
3: http://www.entityframeworktutorial.net/efcore/entity-framework-core-dbcontext.aspx
4: https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext